# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, BSDv3 License
# This file is distributed under the same license as the py4web package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: py4web 1.20240602.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-08 18:37-0700\n"
"PO-Revision-Date: 2024-06-09 00:02-0700\n"
"Last-Translator: \n"
"Language-Team: it <LL@li.org>\n"
"Language: it\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.15.0\n"
"X-Generator: Poedit 3.4.4\n"

#: ../../chapter-07.rst:3
msgid "The Database Abstraction Layer (DAL)"
msgstr "Il livello di astrazione del database (DAL)"

#: ../../chapter-07.rst:6
msgid "DAL introduction"
msgstr "Introduzione al DAL"

#: ../../chapter-07.rst:8
msgid ""
"py4web rely on a database abstraction layer (DAL), an API that maps Python "
"objects into database objects such as queries, tables, and records. The DAL "
"dynamically generates the SQL in real time using the specified dialect for the "
"database back end, so that you do not have to write SQL code or learn different "
"SQL dialects (the term SQL is used generically), and the application will be "
"portable among different types of databases. The DAL choosen is a pure Python "
"one called `pyDAL <https://github.com/web2py/pydal>`__. It was conceived in the "
"web2py project but it's a standard python module: you can use it in any Python "
"context."
msgstr ""
"py4web si basa su un database abstraction layer (DAL), un'API che mappa gli "
"oggetti Python in oggetti di database come query, tabelle e record. Il DAL "
"genera dinamicamente l'SQL in tempo reale utilizzando il dialetto specificato "
"per il back-end del database, in modo che non sia necessario scrivere codice "
"SQL o imparare diversi dialetti SQL (il termine SQL è usato genericamente) e "
"l'applicazione sarà portabile tra diversi tipi di database. Il DAL scelto è un "
"puro Python chiamato 'pyDAL <https://github.com/web2py/pydal>'__. E' stato "
"concepito nel progetto web2py ma è un modulo python standard: si può usare in "
"qualsiasi contesto Python."

#: ../../chapter-07.rst:19
msgid "A little taste of pyDAL features:"
msgstr "Un piccolo assaggio delle caratteristiche di pyDAL:"

#: ../../chapter-07.rst:21
msgid "Transactions"
msgstr "Transazioni"

#: ../../chapter-07.rst:22
msgid "Aggregates"
msgstr "Aggregati"

#: ../../chapter-07.rst:23
msgid "Inner & Outer Joins"
msgstr "Giunzioni interne ed esterne"

#: ../../chapter-07.rst:24
msgid "Nested Selects"
msgstr "Selezioni nidificate"

#: ../../chapter-07.rst:27
msgid "py4web model"
msgstr "Modello PY4Web"

#: ../../chapter-07.rst:29
msgid ""
"Even if web2py and py4web use the same pyDAL, there are important differences "
"(see :ref:`From web2py to py4web` for details). The main caveat is that in "
"py4web only the action is executed for every HTTP request, while the code "
"defined outside of actions is only executed at startup. That makes py4web much "
"faster, in particular when there are many tables. The downside of this approach "
"is that the developer should be careful to never override pyDAL variables "
"inside action or in any way that depends on the content of the request object, "
"else the code is not thread safe. The only variables that can be changed at "
"will are the following field attributes: readable, writable, requires, update, "
"and default. All the others are for practical purposes to be considered global "
"and non thread safe."
msgstr ""
"Anche se web2py e py4web usano lo stesso pyDAL, ci sono importanti differenze "
"(vedere :ref:'From web2py to py4web' per i dettagli). L'avvertenza principale è "
"che in py4web solo l'azione viene eseguita per ogni richiesta HTTP, mentre il "
"codice definito al di fuori delle azioni viene eseguito solo all'avvio. Questo "
"rende py4web molto più veloce, in particolare quando ci sono molte tabelle. Lo "
"svantaggio di questo approccio è che lo sviluppatore deve fare attenzione a non "
"sovrascrivere mai le variabili pyDAL all'interno dell'azione o in qualsiasi "
"modo che dipenda dal contenuto dell'oggetto richiesta, altrimenti il codice non "
"è thread-safe. Le uniche variabili che possono essere modificate a piacimento "
"sono i seguenti attributi di campo: readable, writable, requires, update e "
"default. Tutti gli altri sono ai fini pratici da considerarsi globali e non "
"thread-safe."

#: ../../chapter-07.rst:41
msgid "Supported databases"
msgstr "Database supportati"

#: ../../chapter-07.rst:43
msgid ""
"A partial list of supported databases is show in the table below. Please check "
"on the py4web/pyDAL web site and mailing list for more recent adapters."
msgstr ""
"Un elenco parziale dei database supportati è riportato nella tabella seguente. "
"Si prega di controllare sul sito web py4web/pyDAL e sulla mailing list per gli "
"adattatori più recenti."

#: ../../chapter-07.rst:49
msgid ""
"In any modern python distribution **SQLite** is actually built-in as a Python "
"library. The SQLite driver (sqlite3) is also included: you don't need to "
"install it. Hence this is the most popular database for testing and development."
msgstr ""
"In qualsiasi distribuzione python moderna **SQLite** è in realtà incorporato "
"come libreria Python. È incluso anche il driver SQLite (sqlite3): non è "
"necessario installarlo. Quindi questo è il database più popolare per i test e "
"lo sviluppo."

#: ../../chapter-07.rst:53
msgid ""
"The Windows and the Mac binary distribution work out of the box with SQLite "
"only. To use any other database back end, run a full py4web distribution and "
"install the appropriate driver for the required back end. Once the proper "
"driver is installed, start py4web and it will automatically find the driver."
msgstr ""
"La distribuzione binaria per Windows e Mac funziona solo con SQLite. Per "
"utilizzare qualsiasi altro back-end di database, eseguire una distribuzione "
"py4web completa e installare il driver appropriato per il back-end richiesto. "
"Una volta installato il driver corretto, avvia py4web e troverà automaticamente "
"il driver."

#: ../../chapter-07.rst:59
msgid "Here is a list of the drivers py4web can use:"
msgstr "Ecco un elenco dei driver che py4web può utilizzare:"

#: ../../chapter-07.rst:62 ../../chapter-07.rst:298 ../../chapter-07.rst:482
msgid "Database"
msgstr "Database"

#: ../../chapter-07.rst:62
msgid "Drivers (source)"
msgstr "Driver (sorgente)"

#: ../../chapter-07.rst:64 ../../chapter-07.rst:4800
msgid "SQLite"
msgstr "SQLite"

#: ../../chapter-07.rst:64
msgid "sqlite3 or pysqlite2 or zxJDBC (on Jython)"
msgstr "sqlite3 o pysqlite2 o zxJDBC (su Jython)"

#: ../../chapter-07.rst:65
msgid "PostgreSQL"
msgstr "PostgreSQL"

#: ../../chapter-07.rst:65
msgid "psycopg2 or zxJDBC (on Jython)"
msgstr "psycopg2 o zxJDBC (su Jython)"

#: ../../chapter-07.rst:66 ../../chapter-07.rst:4821
msgid "MySQL"
msgstr "MySQL"

#: ../../chapter-07.rst:66
msgid "pymysql or MySQLdb"
msgstr "pymysql o MySQLdb"

#: ../../chapter-07.rst:67 ../../chapter-07.rst:4893
msgid "Oracle"
msgstr "Oracolo"

#: ../../chapter-07.rst:67
msgid "cx_Oracle"
msgstr "cx_Oracle"

#: ../../chapter-07.rst:68
msgid "MSSQL"
msgstr "MSSQL"

#: ../../chapter-07.rst:68
msgid "pyodbc or pypyodbc"
msgstr "pyodbc o pypyodbc"

#: ../../chapter-07.rst:69
msgid "FireBird"
msgstr "Firebird"

#: ../../chapter-07.rst:69
msgid "kinterbasdb or fdb or pyodbc"
msgstr "KinterbasDB o FDB o Pyodbc"

#: ../../chapter-07.rst:70
msgid "DB2"
msgstr "DB2"

#: ../../chapter-07.rst:70 ../../chapter-07.rst:75
msgid "pyodbc"
msgstr "pyodbc"

#: ../../chapter-07.rst:71
msgid "Informix"
msgstr "Informix"

#: ../../chapter-07.rst:71
msgid "informixdb"
msgstr "informixdb"

#: ../../chapter-07.rst:72
msgid "Ingres"
msgstr "Ingres"

#: ../../chapter-07.rst:72
msgid "ingresdbi"
msgstr "ingresdbi"

#: ../../chapter-07.rst:73
msgid "Cubrid"
msgstr "Cubrid"

#: ../../chapter-07.rst:73
msgid "cubriddb"
msgstr "cubriddb"

#: ../../chapter-07.rst:74
msgid "Sybase"
msgstr "Sybase"

#: ../../chapter-07.rst:75
msgid "Teradata"
msgstr "Teradata"

#: ../../chapter-07.rst:76
msgid "SAPDB"
msgstr "SAPDB"

#: ../../chapter-07.rst:76 ../../chapter-07.rst:4748
msgid "sapdb"
msgstr "sapdb"

#: ../../chapter-07.rst:77
msgid "MongoDB"
msgstr "MongoDB"

#: ../../chapter-07.rst:77
msgid "pymongo"
msgstr "Pymongo"

#: ../../chapter-07.rst:78
msgid "IMAP"
msgstr "IMAP"

#: ../../chapter-07.rst:78
msgid "imaplib"
msgstr "imaplib"

#: ../../chapter-07.rst:81
msgid ""
"Support of MongoDB is experimental. Google NoSQL is treated as a particular "
"case. The Gotchas_ section at the end of this chapter has some more information "
"about specific databases."
msgstr ""
"Il supporto di MongoDB è sperimentale. Google NoSQL viene trattato come un caso "
"particolare. La sezione Gotchas_ alla fine di questo capitolo contiene "
"ulteriori informazioni su database specifici."

#: ../../chapter-07.rst:86
msgid "The DAL: a quick tour"
msgstr "Il DAL: un breve tour"

#: ../../chapter-07.rst:88
msgid "py4web defines the following classes that make up the DAL:"
msgstr "py4web definisce le seguenti classi che costituiscono il DAL:"

#: ../../chapter-07.rst:95
msgid "DAL"
msgstr "DAL"

#: ../../chapter-07.rst:91
msgid "represents a database connection. For example:"
msgstr "rappresenta una connessione al database. Per esempio:"

#: ../../chapter-07.rst:107
msgid "Table"
msgstr "Tabella"

#: ../../chapter-07.rst:98
msgid ""
"represents a database table. You do not directly instantiate Table; instead, "
"``DAL.define_table`` does."
msgstr ""
"Rappresenta una tabella di database. Non si crea direttamente un'istanza di "
"Table. Invece, ''DAL.define_table'' lo fa."

#: ../../chapter-07.rst:105
msgid "The most important methods of a Table are:"
msgstr "I metodi più importanti di una tabella sono:"

#: ../../chapter-07.rst:107
msgid "``insert``, ``truncate``, ``drop``, and ``import_from_csv_file``."
msgstr "''Inserisci'', ''Tronca'', ''Elimina'' e ''import_from_csv_file''."

#: ../../chapter-07.rst:111
msgid "Field"
msgstr "Campo"

#: ../../chapter-07.rst:110
msgid ""
"represents a database field. It can be instantiated and passed as an argument "
"to ``DAL.define_table``."
msgstr ""
"rappresenta un campo di database. Può essere istanziato e passato come "
"argomento a ''DAL.define_table''."

#: ../../chapter-07.rst:119
msgid "Rows"
msgstr "Righe"

#: ../../chapter-07.rst:114
msgid ""
"is the object returned by a database select. It can be thought of as a list of "
"``Row`` rows:"
msgstr ""
"è l'oggetto restituito da una selezione di database. Può essere pensato come un "
"elenco di righe ''Row'':"

#: ../../chapter-07.rst:127
msgid "Row"
msgstr "Riga"

#: ../../chapter-07.rst:122
msgid "contains field values."
msgstr "Contiene i valori dei campi."

#: ../../chapter-07.rst:134
msgid "Query"
msgstr "Query"

#: ../../chapter-07.rst:130
msgid "is an object that represents a SQL “where” clause:"
msgstr "è un oggetto che rappresenta una clausola SQL \"where\":"

#: ../../chapter-07.rst:146
msgid "Set"
msgstr "Imposta"

#: ../../chapter-07.rst:137
msgid ""
"is an object that represents a set of records. Its most important methods are "
"``count``, ``select``, ``update``, and ``delete``. For example:"
msgstr ""
"è un oggetto che rappresenta un set di record. I suoi metodi più importanti "
"sono ''count'', ''select'', ''update'' e ''delete''. Per esempio:"

#: ../../chapter-07.rst:156
msgid "Expression"
msgstr "Espressione"

#: ../../chapter-07.rst:149
msgid ""
"is something like an ``orderby`` or ``groupby`` expression. The Field class is "
"derived from the Expression. Here is an example."
msgstr ""
"è qualcosa di simile a un'espressione ''orderby'' o ''groupby''. La classe "
"Field è derivata dall'oggetto Expression. Ecco un esempio."

#: ../../chapter-07.rst:159
msgid "Using the DAL “stand-alone”"
msgstr "Utilizzo del DAL \"stand-alone\""

#: ../../chapter-07.rst:161
msgid ""
"pyDAL is an independent python package. As such, it can be used without the "
"web2py/py4web environment; you just need to install it with ``pip``. Then "
"import the pydal module when needed:"
msgstr ""
"pyDAL è un pacchetto python indipendente. Come tale, può essere utilizzato "
"senza l'ambiente web2py/py4web; Devi solo installarlo con ''pip''. Quindi "
"importa il modulo pydal quando necessario:"

#: ../../chapter-07.rst:172
msgid ""
"Even if you can import modules directly from pydal, this is not advisable from "
"within py4web applications. Remember that ``py4web.DAL`` is a fixture, ``pydal."
"DAL`` is not. In this context, the last command should better be:"
msgstr ""
"Anche se è possibile importare moduli direttamente da pydal, questo non è "
"consigliabile dall'interno delle applicazioni py4web. Ricordate che ''py4web. "
"DAL'' è un appuntamento fisso, ''pydal. DAL'' non lo è. In questo contesto, "
"l'ultimo comando dovrebbe essere migliore:"

#: ../../chapter-07.rst:181
msgid "Experiment with the py4web shell"
msgstr "Sperimenta con la shell py4web"

#: ../../chapter-07.rst:183
msgid ""
"You can also experiment with the pyDAL API using the py4web shell, that is "
"available using the :ref:`shell command option`."
msgstr ""
"Puoi anche sperimentare con l'API pyDAL usando la shell py4web, che è "
"disponibile usando l'opzione :ref:'shell command'."

#: ../../chapter-07.rst:188
msgid ""
"Mind that database changes may be persistent. So be careful and do NOT hesitate "
"to create a new application for doing testing instead of tampering with an "
"existing one."
msgstr ""
"Tenere presente che le modifiche al database possono essere persistenti. Quindi "
"fai attenzione e NON esitare a creare una nuova applicazione per fare test "
"invece di manometterne una esistente."

#: ../../chapter-07.rst:194
msgid ""
"Note that most of the code snippets that contain the python prompt ``>>>`` are "
"also directly executable via a py4web shell."
msgstr ""
"Si noti che la maggior parte dei frammenti di codice che contengono il prompt "
"python ''>>>'' sono anche direttamente eseguibili tramite una shell py4web."

#: ../../chapter-07.rst:197
msgid "This is a simple example, using the provided ``examples`` app:"
msgstr "Questo è un semplice esempio, usando l'app ''examples'' fornita:"

#: ../../chapter-07.rst:209
msgid ""
"You can also start by creating a connection from zero. For the sake of "
"simplicity, you can use SQLite. Nothing in this discussion changes when you "
"switch the back-end engine."
msgstr ""
"Puoi anche iniziare creando una connessione da zero. Per semplicità, è "
"possibile utilizzare SQLite. In questa discussione non cambia nulla quando si "
"cambia il motore back-end."

#: ../../chapter-07.rst:215
msgid "DAL constructor"
msgstr "Costruttore DAL"

#: ../../chapter-07.rst:217
msgid "Basic use:"
msgstr "Uso di base:"

#: ../../chapter-07.rst:223
msgid ""
"The database is now connected and the connection is stored in the global "
"variable ``db``."
msgstr ""
"Il database è ora connesso e la connessione è memorizzata nella variabile "
"globale ''db''."

#: ../../chapter-07.rst:226
msgid "At any time you can retrieve the connection string."
msgstr "In qualsiasi momento è possibile recuperare la stringa di connessione."

#: ../../chapter-07.rst:233
msgid "and the database name"
msgstr "e il nome del database"

#: ../../chapter-07.rst:240
msgid ""
"The connection string is called ``_uri`` because it is an instance of a uniform "
"resource identifier."
msgstr ""
"La stringa di connessione è chiamata ''_uri'' perché è un'istanza di un uniform "
"resource identifier."

#: ../../chapter-07.rst:243
msgid ""
"The DAL allows multiple connections with the same database or with different "
"databases, even databases of different types. For now, we will assume the "
"presence of a single database since this is the most common situation."
msgstr ""
"Il DAL consente connessioni multiple con lo stesso database o con database "
"diversi, anche di tipo diverso. Per ora, assumeremo la presenza di un unico "
"database poiché questa è la situazione più comune."

#: ../../chapter-07.rst:249
msgid "DAL signature"
msgstr "Firma DAL"

#: ../../chapter-07.rst:279
msgid "Connection strings (the uri parameter)"
msgstr "Stringhe di connessione (parametro uri)"

#: ../../chapter-07.rst:281
msgid ""
"A connection with the database is established by creating an instance of the "
"DAL object:"
msgstr ""
"Una connessione con il database viene stabilita creando un'istanza dell'oggetto "
"DAL:"

#: ../../chapter-07.rst:288
msgid ""
"``db`` is not a keyword; it is a local variable that stores the connection "
"object ``DAL``. You are free to give it a different name. The constructor of "
"``DAL`` requires a single argument, the connection string. The connection "
"string is the only py4web code that depends on a specific back-end database. "
"Here are examples of connection strings for specific types of supported back-"
"end databases (in all cases, we assume the database is running from localhost "
"on its default port and is named “test”):"
msgstr ""
"''db'' non è una parola chiave; è una variabile locale che memorizza l'oggetto "
"di connessione ''DAL''. Sei libero di dargli un nome diverso. Il costruttore di "
"''DAL'' richiede un singolo argomento, la stringa di connessione. La stringa di "
"connessione è l'unico codice py4web che dipende da un database back-end "
"specifico. Di seguito sono riportati alcuni esempi di stringhe di connessione "
"per tipi specifici di database back-end supportati (in tutti i casi, si presume "
"che il database sia in esecuzione da localhost sulla porta predefinita e sia "
"denominato \"test\"):"

#: ../../chapter-07.rst:298
msgid "Connection string"
msgstr "stringa di connessione"

#: ../../chapter-07.rst:300
msgid "**SQLite**"
msgstr "**SQLite**"

#: ../../chapter-07.rst:300
msgid "``sqlite://storage.sqlite``"
msgstr "''sqlite://storage.sqlite''"

#: ../../chapter-07.rst:301 ../../chapter-07.rst:485
msgid "**MySQL**"
msgstr "**MySQL**"

#: ../../chapter-07.rst:301
msgid "``mysql://username:password@localhost/test?set_encoding=utf8mb4``"
msgstr "''mysql://username:password@localhost/test?set_encoding=utf8mb4''"

#: ../../chapter-07.rst:302 ../../chapter-07.rst:484
msgid "**PostgreSQL**"
msgstr "**PostgreSQL**"

#: ../../chapter-07.rst:302
msgid "``postgres://username:password@localhost/test``"
msgstr "''postgres://username:password@localhost/test''"

#: ../../chapter-07.rst:303
msgid "**MSSQL (legacy)**"
msgstr "**MSSQL (legacy)**"

#: ../../chapter-07.rst:303
msgid "``mssql://username:password@localhost/test``"
msgstr "''mssql://username:password@localhost/test''"

#: ../../chapter-07.rst:304
msgid "**MSSQL (>=2005)**"
msgstr "**MSSQL (>=2005)**"

#: ../../chapter-07.rst:304
msgid "``mssql3://username:password@localhost/test``"
msgstr "''mssql3://nomeutente:password@localhost/test''"

#: ../../chapter-07.rst:305
msgid "**MSSQL (>=2012)**"
msgstr "**MSSQL (>=2012)**"

#: ../../chapter-07.rst:305
msgid "``mssql4://username:password@localhost/test``"
msgstr "''mssql4://nomeutente:password@localhost/test''"

#: ../../chapter-07.rst:306 ../../chapter-07.rst:486
msgid "**FireBird**"
msgstr "**Firebird**"

#: ../../chapter-07.rst:306
msgid "``firebird://username:password@localhost/test``"
msgstr "''firebird://username:password@localhost/test''"

#: ../../chapter-07.rst:307 ../../chapter-07.rst:488
msgid "**Oracle**"
msgstr "**Oracolo**"

#: ../../chapter-07.rst:307
msgid "``oracle://username/password@test``"
msgstr "''oracle://username/password@test''"

#: ../../chapter-07.rst:308
msgid "**DB2**"
msgstr "**DB2**"

#: ../../chapter-07.rst:308
msgid "``db2://username:password@test``"
msgstr "''db2://nomeutente:password@test''"

#: ../../chapter-07.rst:309
msgid "**Ingres**"
msgstr "**Ingres**"

#: ../../chapter-07.rst:309
msgid "``ingres://username:password@localhost/test``"
msgstr "''ingres://username:password@localhost/test''"

#: ../../chapter-07.rst:310
msgid "**Sybase**"
msgstr "**Sybase**"

#: ../../chapter-07.rst:310
msgid "``sybase://username:password@localhost/test``"
msgstr "''sybase://username:password@localhost/test''"

#: ../../chapter-07.rst:311
msgid "**Informix**"
msgstr "**Informix**"

#: ../../chapter-07.rst:311
msgid "``informix://username:password@test``"
msgstr "''informix://username:password@test''"

#: ../../chapter-07.rst:312
msgid "**Teradata**"
msgstr "**Teradata**"

#: ../../chapter-07.rst:312
msgid "``teradata://DSN=dsn;UID=user;PWD=pass;DATABASE=test``"
msgstr "''teradata://DSN=dsn; UID=utente; PWD=passaggio; DATABASE=test''"

#: ../../chapter-07.rst:313
msgid "**Cubrid**"
msgstr "**Cubrid**"

#: ../../chapter-07.rst:313
msgid "``cubrid://username:password@localhost/test``"
msgstr "''cubrid://username:password@localhost/test''"

#: ../../chapter-07.rst:314
msgid "**SAPDB**"
msgstr "**SAPDB**"

#: ../../chapter-07.rst:314
msgid "``sapdb://username:password@localhost/test``"
msgstr "''sapdb://username:password@localhost/test''"

#: ../../chapter-07.rst:315
msgid "**IMAP**"
msgstr "**IMAP**"

#: ../../chapter-07.rst:315
msgid "``imap://user:password@server:port``"
msgstr "''imap://utente:password@server:porto''"

#: ../../chapter-07.rst:316
msgid "**MongoDB**"
msgstr "**MongoDB**"

#: ../../chapter-07.rst:316
msgid "``mongodb://username:password@localhost/test``"
msgstr "''mongodb://username:password@localhost/test''"

#: ../../chapter-07.rst:317
msgid "**Google/SQL**"
msgstr "**Google/SQL**"

#: ../../chapter-07.rst:317
msgid "``google:sql://project:instance/database``"
msgstr "''google:sql://project:instance/database''"

#: ../../chapter-07.rst:318
msgid "**Google/NoSQL**"
msgstr "**Google/NoSQL**"

#: ../../chapter-07.rst:318
msgid "``google:datastore``"
msgstr "''google:datastore''"

#: ../../chapter-07.rst:319
msgid "**Google/NoSQL/NDB**"
msgstr "**Google/NoSQL/NDB**"

#: ../../chapter-07.rst:319
msgid "``google:datastore+ndb``"
msgstr "''google:datastore+ndb''"

#: ../../chapter-07.rst:322
msgid ""
"in SQLite the database consists of a single file. If it does not exist, it is "
"created. This file is locked every time it is accessed."
msgstr ""
"in SQLite il database è costituito da un singolo file. Se non esiste, viene "
"creato. Questo file viene bloccato ogni volta che vi si accede."

#: ../../chapter-07.rst:324
msgid ""
"in the case of MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Ingres and "
"Informix the database “test” must be created outside py4web. Once the "
"connection is established, py4web will create, alter, and drop tables "
"appropriately."
msgstr ""
"nel caso di MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Ingres e Informix "
"il database \"test\" deve essere creato al di fuori di py4web. Una volta "
"stabilita la connessione, py4web creerà, modificherà ed eliminerà le tabelle in "
"modo appropriato."

#: ../../chapter-07.rst:328
msgid ""
"in the MySQL connection string, the ``?set_encoding=utf8mb4`` at the end sets "
"the encoding to UTF-8 and avoids an ``Invalid utf8 character string:`` error on "
"Unicode characters that consist of four bytes, as by default, MySQL can only "
"handle Unicode characters that consist of one to three bytes."
msgstr ""
"nella stringa di connessione MySQL, ''?set_encoding=utf8mb4'' alla fine imposta "
"la codifica su UTF-8 ed evita un errore ''Stringa di caratteri utf8 non "
"valida:'' sui caratteri Unicode che consistono di quattro byte, poiché per "
"impostazione predefinita, MySQL può gestire solo caratteri Unicode che "
"consistono da uno a tre byte."

#: ../../chapter-07.rst:333
msgid ""
"in the Google/NoSQL case the ``+ndb`` option turns on NDB. NDB uses a Memcache "
"buffer to read data that is accessed often. This is completely automatic and "
"done at the datastore level, not at the py4web level."
msgstr ""
"nel caso di Google/NoSQL l'opzione ''+ndb'' attiva NDB. NDB utilizza un buffer "
"Memcache per leggere i dati a cui si accede spesso. Questo è completamente "
"automatico e viene fatto a livello di datastore, non a livello di py4web."

#: ../../chapter-07.rst:336
msgid ""
"it is also possible to set the connection string to ``None``. In this case DAL "
"will not connect to any back-end database, but the API can still be accessed "
"for testing."
msgstr ""
"è anche possibile impostare la stringa di connessione a ''None''. In questo "
"caso DAL non si connetterà ad alcun database back-end, ma è comunque possibile "
"accedere all'API per il test."

#: ../../chapter-07.rst:340
msgid ""
"Some times you may also need to generate SQL as if you had a connection but "
"without actually connecting to the database. This can be done with"
msgstr ""
"A volte potrebbe anche essere necessario generare SQL come se si avesse una "
"connessione, ma senza connettersi effettivamente al database. Questo può essere "
"fatto con"

#: ../../chapter-07.rst:347
msgid ""
"In this case you will be able to call ``_select``, ``_insert``, ``_update``, "
"and ``_delete`` to generate SQL but not call ``select``, ``insert``, "
"``update``, and ``delete``; see `Generating raw SQL`_ for details. In most of "
"the cases you can use ``do_connect=False`` even without having the required "
"database drivers."
msgstr ""
"In questo caso sarete in grado di chiamare ''_select'', ''_insert'', "
"''_update'' e ''_delete'' per generare SQL ma non chiamare ''select'', "
"''insert'', ''update'' e ''delete''; vedere 'Generazione di SQL grezzo'_ per i "
"dettagli. Nella maggior parte dei casi è possibile utilizzare "
"''do_connect=False'' anche senza avere i driver di database richiesti."

#: ../../chapter-07.rst:353
msgid ""
"Notice that by default py4web uses utf8 character encoding for databases. If "
"you work with existing databases that behave differently, you have to change it "
"with the optional parameter ``db_codec`` like"
msgstr ""
"Si noti che per impostazione predefinita py4web utilizza la codifica dei "
"caratteri utf8 per i database. Se si lavora con database esistenti che si "
"comportano in modo diverso, è necessario modificarlo con il parametro opzionale "
"''db_codec'' come"

#: ../../chapter-07.rst:361
msgid "Otherwise you’ll get UnicodeDecodeError tickets."
msgstr "In caso contrario, si otterranno ticket UnicodeDecodeError."

#: ../../chapter-07.rst:364
msgid "Connection pooling"
msgstr "Pool di connessioni"

#: ../../chapter-07.rst:366
msgid ""
"A common argument of the DAL constructor is the ``pool_size``; it defaults to "
"zero."
msgstr ""
"Un argomento comune del costruttore DAL è il ''pool_size''; Il valore "
"predefinito è zero."

#: ../../chapter-07.rst:369
msgid ""
"As it is rather slow to establish a new database connection for each request, "
"py4web implements a mechanism for connection pooling. Once a connection is "
"established and the page has been served and the transaction completed, the "
"connection is not closed but goes into a pool. When the next request arrives, "
"py4web tries to recycle a connection from the pool and use that for the new "
"transaction. If there are no available connections in the pool, a new "
"connection is established."
msgstr ""
"Poiché è piuttosto lento stabilire una nuova connessione al database per ogni "
"richiesta, py4web implementa un meccanismo per il pool di connessioni. Una "
"volta stabilita una connessione, la pagina è stata servita e la transazione è "
"stata completata, la connessione non viene chiusa ma viene inserita in un pool. "
"Quando arriva la richiesta successiva, py4web tenta di riciclare una "
"connessione dal pool e di utilizzarla per la nuova transazione. Se non sono "
"disponibili connessioni nel pool, viene stabilita una nuova connessione."

#: ../../chapter-07.rst:378
msgid ""
"When py4web starts, the pool is always empty. The pool grows up to the minimum "
"between the value of ``pool_size`` and the max number of concurrent requests. "
"This means that if ``pool_size=10`` but our server never receives more than 5 "
"concurrent requests, then the actual pool size will only grow to 5. If "
"``pool_size=0`` then connection pooling is not used."
msgstr ""
"All'avvio di py4web, il pool è sempre vuoto. Il pool cresce fino al minimo "
"compreso tra il valore di ''pool_size'' e il numero massimo di richieste "
"simultanee. Ciò significa che se ''pool_size=10'' ma il nostro server non "
"riceve mai più di 5 richieste simultanee, la dimensione effettiva del pool "
"crescerà solo fino a 5. Se ''pool_size=0'' allora il pool di connessioni non "
"viene usato."

#: ../../chapter-07.rst:385
msgid ""
"Connections in the pools are shared sequentially among threads, in the sense "
"that they may be used by two different but not simultaneous threads. There is "
"only one pool for each py4web process."
msgstr ""
"Le connessioni nei pool vengono condivise in modo sequenziale tra i thread, nel "
"senso che possono essere usate da due thread diversi ma non simultanei. C'è un "
"solo pool per ogni processo py4web."

#: ../../chapter-07.rst:389
msgid ""
"The ``pool_size`` parameter is ignored by SQLite and Google App Engine. "
"Connection pooling is ignored for SQLite, since it would not yield any benefit."
msgstr ""
"Il parametro ''pool_size'' viene ignorato da SQLite e Google App Engine. Il "
"pool di connessioni viene ignorato per SQLite, poiché non produrrebbe alcun "
"vantaggio."

#: ../../chapter-07.rst:394
msgid "Connection failures (attempts parameter)"
msgstr "Errori di connessione (parametro tentativi)"

#: ../../chapter-07.rst:396
msgid ""
"If py4web fails to connect to the database it waits 1 second and by default "
"tries again up to 5 times before declaring a failure. In case of connection "
"pooling it is possible that a pooled connection that stays open but unused for "
"some time is closed by the database end. Thanks to the retry feature py4web "
"tries to re-establish these dropped connections. The number of attempts is set "
"via the attempts parameter."
msgstr ""
"Se py4web non riesce a connettersi al database, attende 1 secondo e, per "
"impostazione predefinita, riprova fino a 5 volte prima di dichiarare un errore. "
"In caso di pool di connessioni, è possibile che una connessione in pool che "
"rimane aperta ma inutilizzata per un certo periodo di tempo venga chiusa dalla "
"fine del database. Grazie alla funzione di ripetizione dei tentativi, py4web "
"tenta di ristabilire queste connessioni interrotte. Il numero di tentativi "
"viene impostato tramite il parametro tentativi."

#: ../../chapter-07.rst:404
msgid "Lazy Tables"
msgstr "Tavoli pigri"

#: ../../chapter-07.rst:406
msgid ""
"Setting ``lazy_tables = True`` provides a major performance boost (but not with "
"py4web). It means that table creation is deferred until the table is actually "
"referenced."
msgstr ""
"L'impostazione ''lazy_tables = True'' fornisce un notevole aumento delle "
"prestazioni (ma non con py4web). Significa che la creazione della tabella viene "
"posticipata fino a quando non viene effettivamente fatto riferimento alla "
"tabella."

#: ../../chapter-07.rst:412
msgid ""
"You should never use lazy tables in py4web. There is no advantage, no need, and "
"possibly concurrency problems."
msgstr ""
"Non dovresti mai usare le tabelle pigre in py4web. Non c'è alcun vantaggio, "
"nessuna necessità e possibilmente problemi di concorrenza."

#: ../../chapter-07.rst:416
msgid "Model-less applications"
msgstr "Applicazioni senza modello"

#: ../../chapter-07.rst:418
msgid ""
"In py4web the code defined outside of actions (where normally DAL tables are "
"defined) is only executed at startup."
msgstr ""
"In py4web il codice definito al di fuori delle azioni (dove normalmente sono "
"definite le tabelle DAL) viene eseguito solo all'avvio."

#: ../../chapter-07.rst:421
msgid ""
"However, it is possible to define DAL tables on demand inside actions. This is "
"referred to as “model-less” development by the py4web community."
msgstr ""
"Tuttavia, è possibile definire tabelle DAL su richiesta all'interno di azioni. "
"Questo è indicato come sviluppo \"model-less\" dalla comunità py4web."

#: ../../chapter-07.rst:424
msgid ""
"To use the “model-less” approach, you take responsibility for doing all the "
"housekeeping tasks. You call the table definitions when you need them, and "
"provide database connection passed as parameter. Also, remember "
"maintainability: other py4web developers expect to find database definitions in "
"the ``models.py`` file."
msgstr ""
"Per utilizzare l'approccio \"senza modello\", ti assumi la responsabilità di "
"svolgere tutte le attività di pulizia. Le definizioni di tabella vengono "
"chiamate quando sono necessarie e si fornisce la connessione al database "
"passata come parametro. Inoltre, ricordate la manutenibilità: altri "
"sviluppatori di py4web si aspettano di trovare le definizioni del database nel "
"file ''models.py''."

#: ../../chapter-07.rst:431
msgid "Replicated databases"
msgstr "Database replicati"

#: ../../chapter-07.rst:433
msgid ""
"The first argument of ``DAL(...)`` can be a list of URIs. In this case py4web "
"tries to connect to each of them. The main purpose for this is to deal with "
"multiple database servers and distribute the workload among them. Here is a "
"typical use case:"
msgstr ""
"Il primo argomento di ''DAL(...) '' può essere un elenco di URI. In questo caso "
"py4web tenta di connettersi a ciascuno di essi. Lo scopo principale è quello di "
"gestire più server di database e distribuire il carico di lavoro tra di essi. "
"Ecco un caso d'uso tipico:"

#: ../../chapter-07.rst:442
msgid ""
"In this case the DAL tries to connect to the first and, on failure, it will try "
"the second and the third. This can also be used to distribute load in a "
"database master-slave configuration."
msgstr ""
"In questo caso il DAL tenta di connettersi al primo e, in caso di fallimento, "
"proverà il secondo e il terzo. Questo può essere utilizzato anche per "
"distribuire il carico in una configurazione master-slave del database."

#: ../../chapter-07.rst:447
msgid "Reserved keywords"
msgstr "Parole chiave riservate"

#: ../../chapter-07.rst:449
msgid ""
"``check_reserved`` tells the constructor to check table names and column names "
"against reserved SQL keywords in target back-end databases. ``check_reserved`` "
"defaults to None."
msgstr ""
"''check_reserved'' indica al costruttore di controllare i nomi delle tabelle e "
"dei nomi delle colonne rispetto alle parole chiave SQL riservate nei database "
"back-end di destinazione. Il valore predefinito di ''check_reserved'' è Nessuno."

#: ../../chapter-07.rst:453
msgid ""
"This is a list of strings that contain the database back-end adapter names."
msgstr ""
"Si tratta di un elenco di stringhe che contengono i nomi degli adattatori back-"
"end del database."

#: ../../chapter-07.rst:456
msgid ""
"The adapter name is the same as used in the DAL connection string. So if you "
"want to check against PostgreSQL and MSSQL then your db connection would look "
"as follows:"
msgstr ""
"Il nome dell'adapter è lo stesso utilizzato nella stringa di connessione DAL. "
"Quindi, se vuoi controllare PostgreSQL e MSSQL, la tua connessione db sarà "
"simile alla seguente:"

#: ../../chapter-07.rst:464
msgid "The DAL will scan the keywords in the same order as of the list."
msgstr ""
"Il DAL eseguirà la scansione delle parole chiave nello stesso ordine "
"dell'elenco."

#: ../../chapter-07.rst:466
msgid ""
"There are two extra options “all” and “common”. If you specify all, it will "
"check against all known SQL keywords. If you specify common, it will only check "
"against common SQL keywords such as ``SELECT``, ``INSERT``, ``UPDATE``, etc."
msgstr ""
"Ci sono due opzioni extra \"tutte\" e \"comuni\". Se si specifica all, verranno "
"eseguite tutte le parole chiave SQL note. Se specifichi common, controllerà "
"solo le parole chiave SQL comuni come ''SELECT'', ''INSERT'', ''UPDATE'', ecc."

#: ../../chapter-07.rst:471
msgid ""
"For supported back ends you may also specify if you would like to check against "
"the non-reserved SQL keywords as well. In this case you would append "
"``_nonreserved`` to the name. For example:"
msgstr ""
"Per i back-end supportati, è anche possibile specificare se si desidera "
"eseguire il controllo anche in base alle parole chiave SQL non riservate. In "
"questo caso si dovrebbe aggiungere ''_nonreserved'' al nome. Per esempio:"

#: ../../chapter-07.rst:479
msgid "The following database backends support reserved words checking."
msgstr ""
"I seguenti backend di database supportano il controllo delle parole riservate."

#: ../../chapter-07.rst:482
msgid "check_reserved"
msgstr "check_reserved"

#: ../../chapter-07.rst:484
msgid "``postgres(_nonreserved)``"
msgstr "''postgres(_nonreserved)''"

#: ../../chapter-07.rst:485
msgid "``mysql``"
msgstr "''mysql''"

#: ../../chapter-07.rst:486
msgid "``firebird(_nonreserved)``"
msgstr "''uccello di fuoco(_nonreserved)''"

#: ../../chapter-07.rst:487
msgid "**MSSQL**"
msgstr "**MSSQL**"

#: ../../chapter-07.rst:487
msgid "``mssql``"
msgstr "''mssql''"

#: ../../chapter-07.rst:488
msgid "``oracle``"
msgstr "''Oracolo''"

#: ../../chapter-07.rst:492
msgid "Database quoting and case settings"
msgstr "Quotazione del database e impostazioni dei casi"

#: ../../chapter-07.rst:494
msgid "Quoting of SQL entities are enabled by default in DAL, that is:"
msgstr ""
"Le virgolette di entità SQL sono abilitate per impostazione predefinita in DAL, "
"ovvero:"

#: ../../chapter-07.rst:496
msgid "``entity_quoting = True``"
msgstr "''entity_quoting = Vero''"

#: ../../chapter-07.rst:498
msgid ""
"This way identifiers are automatically quoted in SQL generated by DAL. At SQL "
"level keywords and unquoted identifiers are case insensitive, thus quoting an "
"SQL identifier makes it case sensitive."
msgstr ""
"In questo modo gli identificatori vengono automaticamente citati in SQL "
"generato da DAL. A livello SQL, le parole chiave e gli identificatori non "
"racchiusi tra virgolette non fanno distinzione tra maiuscole e minuscole, "
"quindi la citazione di un identificatore SQL fa distinzione tra maiuscole e "
"minuscole."

#: ../../chapter-07.rst:502
msgid ""
"Notice that unquoted identifiers should always be folded to lower case by the "
"back-end engine according to SQL standard but not all engines are compliant "
"with this (for example PostgreSQL default folding is upper case)."
msgstr ""
"Si noti che gli identificatori non racchiusi tra virgolette devono sempre "
"essere ripiegati in minuscolo dal motore back-end in base allo standard SQL, ma "
"non tutti i motori sono conformi a questo (ad esempio, la piegatura predefinita "
"di PostgreSQL è maiuscola)."

#: ../../chapter-07.rst:507
msgid "By default DAL ignores field case too, to change this use:"
msgstr ""
"Per impostazione predefinita, DAL ignora anche le maiuscole e minuscole del "
"campo, per modificare questo utilizzo:"

#: ../../chapter-07.rst:509
msgid "``ignore_field_case = False``"
msgstr "''ignore_field_case = Falso''"

#: ../../chapter-07.rst:511
msgid ""
"To be sure of using the same names in python and in the DB schema, you must "
"arrange for both settings above. Here is an example:"
msgstr ""
"Per essere sicuri di utilizzare gli stessi nomi in python e nello schema del "
"database, è necessario organizzare entrambe le impostazioni di cui sopra. Ecco "
"un esempio:"

#: ../../chapter-07.rst:521
msgid "Making a secure connection"
msgstr "Stabilire una connessione sicura"

#: ../../chapter-07.rst:523
msgid ""
"Sometimes it is necessary (and advised) to connect to your database using "
"secure connection, especially if your database is not on the same server as "
"your application. In this case you need to pass additional parameters to the "
"database driver. You should refer to database driver documentation for details."
msgstr ""
"A volte è necessario (e consigliato) connettersi al database utilizzando una "
"connessione protetta, soprattutto se il database non si trova sullo stesso "
"server dell'applicazione. In questo caso è necessario passare parametri "
"aggiuntivi al driver del database. Per ulteriori informazioni, fare riferimento "
"alla documentazione del driver del database."

#: ../../chapter-07.rst:529
msgid "For PostgreSQL with psycopg2 it should look like this:"
msgstr "Per PostgreSQL con psycopg2 dovrebbe essere simile a questo:"

#: ../../chapter-07.rst:537
msgid ""
"where parameters ``sslrootcert``, ``sslcert`` and ``sslkey`` should contain the "
"full path to the files. You should refer to PostgreSQL documentation on how to "
"configure PostgreSQL server to accept secure connections."
msgstr ""
"dove i parametri ''sslrootcert'', ''sslcert'' e ''sslkey'' dovrebbero contenere "
"il percorso completo dei file. È necessario fare riferimento alla "
"documentazione di PostgreSQL su come configurare il server PostgreSQL per "
"accettare connessioni sicure."

#: ../../chapter-07.rst:543
msgid "Other DAL constructor parameters"
msgstr "Altri parametri del costruttore DAL"

#: ../../chapter-07.rst:546
msgid "Database folder location"
msgstr "Percorso della cartella del database"

#: ../../chapter-07.rst:548
msgid ""
"``folder`` sets the place where migration files will be created (see "
"Migrations_ for details). It is also used for SQLite databases. Automatically "
"set within py4web. Set a path when using DAL outside py4web."
msgstr ""
"''Cartella'' imposta il luogo in cui verranno creati i file di migrazione "
"(vedere Migrations_ per i dettagli). Viene utilizzato anche per i database "
"SQLite. Impostato automaticamente all'interno di py4web. Impostare un percorso "
"quando si utilizza DAL al di fuori di py4web."

#: ../../chapter-07.rst:554
msgid "Default migration settings"
msgstr "Impostazioni di migrazione predefinite"

#: ../../chapter-07.rst:556
msgid ""
"The DAL constructor migration settings are booleans affecting defaults and "
"global behaviour."
msgstr ""
"Le impostazioni di migrazione del costruttore DAL sono valori booleani che "
"influiscono sulle impostazioni predefinite e sul comportamento globale."

#: ../../chapter-07.rst:559
msgid "``migrate = True`` sets default migrate behavior for all tables"
msgstr ""
"''migrate = True'' imposta il comportamento di migrazione predefinito per tutte "
"le tabelle"

#: ../../chapter-07.rst:561
msgid "``fake_migrate = False`` sets default fake_migrate behavior for all tables"
msgstr ""
"''fake_migrate = False'' imposta il comportamento predefinito fake_migrate per "
"tutte le tabelle"

#: ../../chapter-07.rst:564
msgid "``migrate_enabled = True`` If set to False disables ALL migrations"
msgstr ""
"''migrate_enabled = True'' Se impostato su False disabilita TUTTE le migrazioni"

#: ../../chapter-07.rst:566
msgid "``fake_migrate_all = False`` If set to True fake migrates ALL tables"
msgstr ""
"''fake_migrate_all = False'' Se impostato su True fake migra TUTTE le tabelle"

#: ../../chapter-07.rst:569
msgid "``commit`` and ``rollback``"
msgstr "''commit'' e ''rollback''"

#: ../../chapter-07.rst:571
msgid ""
"The insert, truncate, delete, and update operations aren't actually committed "
"until py4web issues the commit command. The create and drop operations may be "
"executed immediately, depending on the database engine."
msgstr ""
"Le operazioni di inserimento, troncamento, eliminazione e aggiornamento non "
"vengono effettivamente eseguite fino a quando py4web non esegue il comando "
"commit. Le operazioni di creazione ed eliminazione possono essere eseguite "
"immediatamente, a seconda del motore di database."

#: ../../chapter-07.rst:576
msgid ""
"If you pass ``db`` in an ``action.uses`` decorator, you don't need to call "
"commit in the controller, it is done for you.  (Also, if you use "
"``authenticated`` or ``unauthenticated`` decorator.)"
msgstr ""
"Se passate ''db'' in un decoratore ''action.uses'', non c'è bisogno di chiamare "
"commit nel controller, è fatto per voi.  (Inoltre, se si usa il decoratore "
"''autenticato'' o ''non autenticato''.)"

#: ../../chapter-07.rst:582
msgid ""
"always add ``db`` in an ``action.uses`` decorator (or use the ``authenticated`` "
"or ``unauthenticated`` decorator). Otherwise you have to add ``db.commit()`` in "
"every define_table and in every table activities: insert(), update(), delete()"
msgstr ""
"Aggiungere sempre ''db'' in un decoratore ''action.uses'' (o usare il "
"decoratore ''authenticated'' o ''unauthenticated''). Altrimenti devi aggiungere "
"''db.commit()'' in ogni define_table e in ogni attività della tabella: "
"insert(), update(), delete()"

#: ../../chapter-07.rst:587
msgid ""
"So in actions there is normally no need to ever call ``commit`` or ``rollback`` "
"explicitly in py4web unless you need more granular control."
msgstr ""
"Quindi nelle azioni normalmente non c'è bisogno di chiamare ''commit'' o "
"''rollback'' in modo esplicito in py4web, a meno che non si abbia bisogno di un "
"controllo più granulare."

#: ../../chapter-07.rst:591
msgid ""
"But if you executed commands via the shell, you are required to manually commit:"
msgstr ""
"Ma se hai eseguito comandi tramite la shell, ti viene richiesto di eseguire "
"manualmente il commit:"

#: ../../chapter-07.rst:598
msgid "To check it let’s insert a new record:"
msgstr "Per verificarlo inseriamo un nuovo record:"

#: ../../chapter-07.rst:605
msgid "and roll back, i.e., ignore all operations since the last commit:"
msgstr "e rollback, cioè ignora tutte le operazioni dall'ultimo commit:"

#: ../../chapter-07.rst:611
msgid ""
"If you now insert again, the counter will again be set to 2, since the previous "
"insert was rolled back."
msgstr ""
"Se ora si inserisce di nuovo, il contatore verrà nuovamente impostato su 2, "
"poiché è stato eseguito il rollback dell'inserimento precedente."

#: ../../chapter-07.rst:619
msgid ""
"Code in models, views and controllers is enclosed in py4web code that looks "
"like this (pseudo code):"
msgstr ""
"Il codice nei modelli, nelle viste e nei controller è racchiuso nel codice "
"py4web che assomiglia a questo (pseudo codice):"

#: ../../chapter-07.rst:636
msgid "Table constructor"
msgstr "Costruttore di tabelle"

#: ../../chapter-07.rst:638
msgid "Tables are defined in the DAL via ``define_table``."
msgstr "Le tabelle sono definite nel DAL tramite ''define_table''."

#: ../../chapter-07.rst:641
msgid "define_table signature"
msgstr "define_table firma"

#: ../../chapter-07.rst:643
msgid "The signature for define_table method is:"
msgstr "La firma per define_table metodo è:"

#: ../../chapter-07.rst:649
msgid ""
"It accepts a mandatory table name and an optional number of ``Field`` instances "
"(even none). You can also pass a ``Table`` (or subclass) object instead of a "
"``Field`` one, this clones and adds all the fields (but the “id”) to the "
"defining table. Other optional keyword args are: ``rname``, ``redefine``, "
"``common_filter``, ``fake_migrate``, ``fields``, ``format``, ``migrate``, "
"``on_define``, ``plural``, ``polymodel``, ``primarykey``, ``sequence_name``, "
"``singular``, ``table_class``, and ``trigger_name``, which are discussed below."
msgstr ""
"Accetta un nome di tabella obbligatorio e un numero opzionale di istanze "
"''Field'' (anche nessuna). Puoi anche passare un oggetto ''Table'' (o "
"sottoclasse) invece di uno ''Field'', questo clona e aggiunge tutti i campi "
"(tranne l'\"id\") alla tabella di definizione. Altre parole chiave opzionali "
"sono: ''rname'', ''redefine'', ''common_filter'', ''fake_migrate'', ''fields'', "
"''format'', ''migrate'', ''on_define'', ''plural'', ''polymodel'', "
"''primarykey'', ''sequence_name'', ''singular'', ''table_class'' e "
"''trigger_name'', che sono discussi di seguito."

#: ../../chapter-07.rst:658 ../../chapter-07.rst:4559
msgid "For example:"
msgstr "Ad esempio:"

#: ../../chapter-07.rst:665
msgid ""
"It defines, stores and returns a ``Table`` object called “person” containing a "
"field (column) “name”. This object can also be accessed via ``db.person``, so "
"you do not need to catch the value returned by define_table."
msgstr ""
"Definisce, memorizza e restituisce un oggetto ''Table'' chiamato \"person\" "
"contenente un campo (colonna) \"name\". È possibile accedere a questo oggetto "
"anche tramite ''db.person'', quindi non è necessario catturare il valore "
"restituito da define_table."

#: ../../chapter-07.rst:671
msgid "``id``: Notes about the primary key"
msgstr "''id'': Note sulla chiave primaria"

#: ../../chapter-07.rst:673
msgid ""
"Do not declare a field called “id”, because one is created by py4web anyway. "
"Every table has a field called “id” by default. It is an auto-increment integer "
"field (usually starting at 1) used for cross-reference and for making every "
"record unique, so “id” is a primary key. (Note: the id counter starting at 1 is "
"back-end specific. For example, this does not apply to the Google App Engine "
"NoSQL.)"
msgstr ""
"Non dichiarare un campo chiamato \"id\", perché ne viene comunque creato uno da "
"py4web. Ogni tabella ha un campo chiamato \"id\" per impostazione predefinita. "
"Si tratta di un campo intero a incremento automatico (di solito a partire da 1) "
"utilizzato per i riferimenti incrociati e per rendere unico ogni record, quindi "
"\"id\" è una chiave primaria. (Nota: il contatore id a partire da 1 è specifico "
"del back-end. Ad esempio, questo non si applica a Google App Engine NoSQL."

#: ../../chapter-07.rst:680
msgid ""
"Optionally you can define a field of ``type='id'`` and py4web will use this "
"field as auto-increment id field. This is not recommended except when accessing "
"legacy database tables which have a primary key under a different name. With "
"some limitation, you can also use different primary keys using the "
"``primarykey`` parameter."
msgstr ""
"Opzionalmente è possibile definire un campo di ''type='id''' e py4web userà "
"questo campo come campo id di incremento automatico. Questa operazione non è "
"consigliata, tranne quando si accede a tabelle di database legacy che hanno una "
"chiave primaria con un nome diverso. Con alcune limitazioni, è anche possibile "
"utilizzare chiavi primarie diverse usando il parametro ''primarykey''."

#: ../../chapter-07.rst:687
msgid "``plural`` and ``singular``"
msgstr "''plurale'' e ''singolare''"

#: ../../chapter-07.rst:689
msgid ""
"As pyDAL is a general DAL, it includes plural and singular attributes to refer "
"to the table names so that external elements can use the proper name for a "
"table."
msgstr ""
"Poiché pyDAL è un DAL generale, include attributi plurali e singolari per fare "
"riferimento ai nomi delle tabelle in modo che gli elementi esterni possano "
"usare il nome corretto per una tabella."

#: ../../chapter-07.rst:694
msgid "``redefine``"
msgstr "''ridefinire''"

#: ../../chapter-07.rst:696
msgid ""
"Tables can be defined only once but you can force py4web to redefine an "
"existing table:"
msgstr ""
"Le tabelle possono essere definite una sola volta, ma è possibile forzare "
"py4web a ridefinire una tabella esistente:"

#: ../../chapter-07.rst:704
msgid "The redefinition may trigger a migration if table definition changes."
msgstr ""
"La ridefinizione può attivare una migrazione se la definizione della tabella "
"viene modificata."

#: ../../chapter-07.rst:707
msgid "``format``: Record representation"
msgstr "''format'': Rappresentazione dei record"

#: ../../chapter-07.rst:709
msgid ""
"It is optional but recommended to specify a format representation for records "
"with the ``format`` parameter."
msgstr ""
"E' facoltativo ma si consiglia di specificare una rappresentazione del formato "
"per i record con il parametro ''format''."

#: ../../chapter-07.rst:716
msgid "or"
msgstr "o"

#: ../../chapter-07.rst:722
msgid "or even more complex ones using a function:"
msgstr "o ancora più complessi utilizzando una funzione:"

#: ../../chapter-07.rst:729
msgid "The format attribute will be used for two purposes:"
msgstr "L'attributo format verrà utilizzato per due scopi:"

#: ../../chapter-07.rst:731
msgid "To represent referenced records in select/option drop-downs."
msgstr ""
"Per rappresentare i record a cui si fa riferimento negli elenchi a discesa di "
"selezione/opzione."

#: ../../chapter-07.rst:732
msgid ""
"To set the ``db.othertable.otherfield.represent`` attribute for all fields "
"referencing this table. This means that the ``Form`` constructor will not show "
"references by id but will use the preferred format representation instead."
msgstr ""
"Per impostare l'attributo ''db.othertable.otherfield.represent'' per tutti i "
"campi che fanno riferimento a questa tabella. Ciò significa che il costruttore "
"''Form'' non mostrerà i riferimenti per id ma userà invece la rappresentazione "
"del formato preferito."

#: ../../chapter-07.rst:738
msgid "``rname``: Real name"
msgstr "''rname'': Vero nome"

#: ../../chapter-07.rst:740
msgid ""
"``rname`` sets a database backend name for the table. This makes the py4web "
"table name an alias, and ``rname`` is the real name used when constructing the "
"query for the backend. To illustrate just one use, ``rname`` can be used to "
"provide MSSQL fully qualified table names accessing tables belonging to other "
"databases on the server: ``rname = 'db1.dbo.table1'``"
msgstr ""
"''rname'' imposta un nome di backend del database per la tabella. Questo rende "
"il nome della tabella py4web un alias, e ''rname'' è il vero nome usato quando "
"si costruisce la query per il backend. Per illustrare solo un utilizzo, "
"''rname'' può essere usato per fornire nomi di tabella completi MSSQL che "
"accedono a tabelle appartenenti ad altri database sul server: ''rname = 'db1."
"dbo.table1'''"

#: ../../chapter-07.rst:748
msgid "``primarykey``: Support for legacy tables"
msgstr "''primarykey'': supporto per le tabelle legacy"

#: ../../chapter-07.rst:750
msgid ""
"``primarykey`` helps support legacy tables with existing primary keys, even "
"multi-part. See `Legacy databases and keyed tables`_."
msgstr ""
"''PrimaryKey'' aiuta a supportare le tabelle legacy con chiavi primarie "
"esistenti, anche multi-parte. Vedere 'Database legacy e tabelle con chiave'_."

#: ../../chapter-07.rst:754
msgid "``migrate``, ``fake_migrate``"
msgstr "''migrare'', ''fake_migrate''"

#: ../../chapter-07.rst:756
msgid ""
"``migrate`` sets migration options for the table. Refer to `Migrations`_ for "
"details."
msgstr ""
"''migrate'' imposta le opzioni di migrazione per la tabella. Per informazioni "
"dettagliate, fare riferimento a 'Migrazioni'_."

#: ../../chapter-07.rst:760
msgid "``table_class``"
msgstr "''table_class''"

#: ../../chapter-07.rst:762
msgid ""
"If you define your own table class as a sub-class of pydal.objects.Table, you "
"can provide it here; this allows you to extend and override methods. Example:"
msgstr ""
"Se si definisce la propria classe table come sottoclasse di pydal.objects."
"Table, è possibile fornirla qui; In questo modo è possibile estendere ed "
"eseguire l'override dei metodi. Esempio:"

#: ../../chapter-07.rst:776
msgid "``sequence_name``"
msgstr "''sequence_name''"

#: ../../chapter-07.rst:778
msgid ""
"The name of a custom table sequence (if supported by the database). Can create "
"a SEQUENCE (starting at 1 and incrementing by 1) or use this for legacy tables "
"with custom sequences."
msgstr ""
"Nome di una sequenza di tabelle personalizzata (se supportata dal database). "
"Può creare una SEQUENZA (a partire da 1 e incrementando di 1) o utilizzarla per "
"tabelle legacy con sequenze personalizzate."

#: ../../chapter-07.rst:782
msgid ""
"Note that when necessary, py4web will create sequences automatically by default."
msgstr ""
"Si noti che, quando necessario, py4web creerà automaticamente le sequenze per "
"impostazione predefinita."

#: ../../chapter-07.rst:786
msgid "``trigger_name``"
msgstr "''trigger_name''"

#: ../../chapter-07.rst:788
msgid ""
"Relates to ``sequence_name``. Relevant for some backends which do not support "
"auto-increment numeric fields."
msgstr ""
"Si riferisce a ''sequence_name''. Rilevante per alcuni backend che non "
"supportano l'incremento automatico dei campi numerici."

#: ../../chapter-07.rst:792
msgid "``polymodel``"
msgstr "''Polimodello''"

#: ../../chapter-07.rst:794
msgid "For use with Google App Engine."
msgstr "Da utilizzare con Google App Engine."

#: ../../chapter-07.rst:797
msgid "``on_define``"
msgstr "''on_define''"

#: ../../chapter-07.rst:799
msgid ""
"``on_define`` is a callback triggered when a lazy_table is instantiated, "
"although it is called anyway if the table is not lazy. This allows dynamic "
"changes to the table without losing the advantages of delayed instantiation."
msgstr ""
"''on_define'' è un callback attivato quando viene creata un'istanza di un "
"lazy_table, anche se viene chiamato comunque se la tabella non è pigra. In "
"questo modo è possibile apportare modifiche dinamiche alla tabella senza "
"perdere i vantaggi della creazione di istanze ritardate."

#: ../../chapter-07.rst:804
msgid "Example:"
msgstr "Esempio:"

#: ../../chapter-07.rst:816
msgid ""
"Note this example shows how to use ``on_define`` but it is not actually "
"necessary. The simple ``requires`` values could be added to the Field "
"definitions and the table would still be lazy. However, ``requires`` which take "
"a Set object as the first argument, such as IS_IN_DB, will make a query like "
"``db.sometable.somefield == some_value`` which would cause ``sometable`` to be "
"defined early. This is the situation saved by ``on_define``."
msgstr ""
"Nota: questo esempio mostra come usare ''on_define'', ma in realtà non è "
"necessario. I semplici valori ''requires'' potrebbero essere aggiunti alle "
"definizioni dei campi e la tabella sarebbe ancora pigra. Tuttavia, ''requires'' "
"che accetta un oggetto Set come primo argomento, come IS_IN_DB, creerà una "
"query come ''db.sometable.somefield == some_value'' che causerebbe la "
"definizione anticipata di ''sometable''. Questa è la situazione salvata da "
"''on_define''."

#: ../../chapter-07.rst:825
msgid "Adding attributes to fields and tables"
msgstr "Aggiunta di attributi a campi e tabelle"

#: ../../chapter-07.rst:827
msgid ""
"If you need to add custom attributes to fields, you can simply do this: ``db."
"table.field.extra = {}``"
msgstr ""
"Se hai bisogno di aggiungere attributi personalizzati ai campi, puoi "
"semplicemente fare questo: ''db.table.field.extra = {}''"

#: ../../chapter-07.rst:830
msgid ""
"“extra” is not a keyword; it’s a custom attribute now attached to the field "
"object. You can do it with tables too but they must be preceded by an "
"underscore to avoid naming conflicts with fields:"
msgstr ""
"\"extra\" non è una parola chiave; Si tratta di un attributo personalizzato ora "
"associato all'oggetto campo. Puoi farlo anche con le tabelle, ma devono essere "
"precedute da un carattere di sottolineatura per evitare conflitti di "
"denominazione con i campi:"

#: ../../chapter-07.rst:839
msgid "Legacy databases and keyed tables"
msgstr "Database legacy e tabelle con chiave"

#: ../../chapter-07.rst:841
msgid "py4web can connect to legacy databases under some conditions."
msgstr "py4web può connettersi a database legacy in alcune condizioni."

#: ../../chapter-07.rst:843
msgid "The easiest way is when these conditions are met:"
msgstr "Il modo più semplice è quando sono soddisfatte queste condizioni:"

#: ../../chapter-07.rst:845
msgid "Each table must have a unique auto-increment integer field called “id”."
msgstr ""
"Ogni tabella deve avere un campo intero univoco a incremento automatico "
"denominato \"id\"."

#: ../../chapter-07.rst:846
msgid "Records must be referenced exclusively using the “id” field."
msgstr ""
"È necessario fare riferimento ai record esclusivamente utilizzando il campo "
"\"id\"."

#: ../../chapter-07.rst:848
msgid ""
"When accessing an existing table, i.e., a table not created by py4web in the "
"current application, always set ``migrate=False``."
msgstr ""
"Quando si accede a una tabella esistente, cioè una tabella non creata da py4web "
"nell'applicazione corrente, impostare sempre ''migrate=False''."

#: ../../chapter-07.rst:851
msgid ""
"If the legacy table has an auto-increment integer field but it is not called "
"“id”, py4web can still access it but the table definition must declare the auto-"
"increment field with ‘id’ type (that is using ``Field('...', 'id')``)."
msgstr ""
"Se la tabella legacy ha un campo intero a incremento automatico ma non è "
"chiamato \"id\", py4web può ancora accedervi ma la definizione della tabella "
"deve dichiarare il campo a incremento automatico con il tipo 'id' (che utilizza "
"''Field('...', 'id')'')."

#: ../../chapter-07.rst:856
msgid ""
"Finally if the legacy table uses a primary key that is not an auto-increment id "
"field it is possible to use a “keyed table”, for example:"
msgstr ""
"Infine, se la tabella legacy utilizza una chiave primaria che non è un campo id "
"a incremento automatico, è possibile utilizzare una \"tabella con chiave\", ad "
"esempio:"

#: ../../chapter-07.rst:869
msgid "``primarykey`` is a list of the field names that make up the primary key."
msgstr ""
"''PrimaryKey'' è un elenco dei nomi dei campi che compongono la chiave primaria."

#: ../../chapter-07.rst:871
msgid "All primarykey fields have a ``NOT NULL`` set even if not specified."
msgstr ""
"Tutti i campi primarykey hanno un ''NOT NULL'' impostato anche se non "
"specificato."

#: ../../chapter-07.rst:872
msgid "Keyed tables can only reference other keyed tables."
msgstr ""
"Le tabelle con chiave possono fare riferimento solo ad altre tabelle con chiave."

#: ../../chapter-07.rst:873
msgid "Referencing fields must use the ``reference tablename.fieldname`` format."
msgstr ""
"I campi di riferimento devono usare il formato ''nometabella di riferimento."
"nomecampo''."

#: ../../chapter-07.rst:875
msgid "The ``update_record`` function is not available for Rows of keyed tables."
msgstr ""
"La funzione ''update_record'' non è disponibile per le righe di tabelle con "
"chiave."

#: ../../chapter-07.rst:880
msgid ""
"Currently keyed tables are only supported for DB2, MSSQL, Ingres and Informix, "
"but others engines will be added."
msgstr ""
"Le tabelle attualmente con chiave sono supportate solo per DB2, MSSQL, Ingres e "
"Informix, ma verranno aggiunti altri motori."

#: ../../chapter-07.rst:883
msgid ""
"At the time of writing, we cannot guarantee that the ``primarykey`` attribute "
"works with every existing legacy table and every supported database backend. "
"For simplicity, we recommend, if possible, creating a database view that has an "
"auto-increment id field."
msgstr ""
"Al momento in cui scriviamo, non possiamo garantire che l'attributo "
"''primarykey'' funzioni con ogni tabella legacy esistente e con ogni backend di "
"database supportato. Per semplicità, si consiglia, se possibile, di creare una "
"vista di database con un campo id a incremento automatico."

#: ../../chapter-07.rst:890
msgid "Field constructor"
msgstr "Costruttore di campo"

#: ../../chapter-07.rst:892
msgid "These are the default values of a Field constructor:"
msgstr "Di seguito sono riportati i valori predefiniti di un costruttore Field:"

#: ../../chapter-07.rst:906
msgid ""
"where DEFAULT is a special value used to allow the value None for a parameter."
msgstr ""
"dove DEFAULT è un valore speciale utilizzato per consentire il valore None per "
"un parametro."

#: ../../chapter-07.rst:909
msgid ""
"Not all of them are relevant for every field. ``length`` is relevant only for "
"fields of type “string”. ``uploadfield``, ``authorize``, and ``autodelete`` are "
"relevant only for fields of type “upload”. ``ondelete`` is relevant only for "
"fields of type “reference” and “upload”."
msgstr ""
"Non tutti sono rilevanti per ogni campo. ''length'' è rilevante solo per i "
"campi di tipo \"stringa\". ''UploadField'', ''Authorize'' e ''Autodelete'' sono "
"rilevanti solo per i campi di tipo 'upload''. ''ondelete'' è rilevante solo per "
"i campi di tipo \"reference\" e \"upload\"."

#: ../../chapter-07.rst:915
msgid ""
"``length`` sets the maximum length of a “string”, “password” or “upload” field. "
"If ``length`` is not specified a default value is used but the default value is "
"not guaranteed to be backward compatible. *To avoid unwanted migrations on "
"upgrades, we recommend that you always specify the length for string, password "
"and upload fields.*"
msgstr ""
"''length'' imposta la lunghezza massima di un campo ''stringa'', 'password'' o "
"'upload''. Se ''length'' non è specificato, viene utilizzato un valore "
"predefinito, ma non è garantito che il valore predefinito sia compatibile con "
"le versioni precedenti. *Per evitare migrazioni indesiderate durante gli "
"aggiornamenti, si consiglia di specificare sempre la lunghezza dei campi "
"stringa, password e caricamento.*"

#: ../../chapter-07.rst:921
msgid ""
"``default`` sets the default value for the field. The default value is used "
"when performing an insert if a value is not explicitly specified. It is also "
"used to pre-populate forms built from the table using ``Form``. Note, rather "
"than being a fixed value, the default can instead be a function (including a "
"lambda function) that returns a value of the appropriate type for the field. In "
"that case, the function is called once for each record inserted, even when "
"multiple records are inserted in a single transaction."
msgstr ""
"''default'' imposta il valore predefinito per il campo. Il valore predefinito "
"viene utilizzato quando si esegue un inserimento se non viene specificato in "
"modo esplicito un valore. Viene anche usato per precompilare i moduli creati "
"dalla tabella usando ''Form''. Si noti che, anziché essere un valore fisso, "
"l'impostazione predefinita può essere una funzione (inclusa una funzione "
"lambda) che restituisce un valore del tipo appropriato per il campo. In tal "
"caso, la funzione viene chiamata una volta per ogni record inserito, anche "
"quando vengono inseriti più record in una singola transazione."

#: ../../chapter-07.rst:929
msgid ""
"``required`` tells the DAL that no insert should be allowed on this table if a "
"value for this field is not explicitly specified."
msgstr ""
"''required'' dice al DAL che nessun inserimento deve essere consentito in "
"questa tabella se un valore per questo campo non è specificato in modo "
"esplicito."

#: ../../chapter-07.rst:931
msgid ""
"``requires`` is a **validator** or a list of validators. This is not used by "
"the DAL, but instead it is used by ``Form`` (this will be explained better on "
"the :ref:`Forms` chapter). The default validators for the given types are shown "
"in the next section :ref:`Field types and validators`."
msgstr ""
"''requires'' è un **validatore** o una lista di validatori. Questo non è usato "
"dal DAL, ma invece è usato da ''Form'' (questo sarà spiegato meglio nel "
"capitolo :ref:'Forms'). I validatori predefiniti per i tipi specificati sono "
"mostrati nella sezione successiva :ref:'Tipi di campo e validatori'."

#: ../../chapter-07.rst:939
msgid ""
"while ``requires=...`` is enforced at the level of forms, ``required=True`` is "
"enforced at the level of the DAL (insert). In addition, ``notnull``, ``unique`` "
"and ``ondelete`` are enforced at the level of the database. While they "
"sometimes may seem redundant, it is important to maintain the distinction when "
"programming with the DAL."
msgstr ""
"mentre ''requires=...'' viene applicato a livello di forms, ''required=True'' "
"viene applicato a livello di DAL (insert). Inoltre, ''notnull'', ''unique'' e "
"''ondelete'' sono applicati a livello di database. Anche se a volte possono "
"sembrare ridondanti, è importante mantenere la distinzione quando si programma "
"con il DAL."

#: ../../chapter-07.rst:946
msgid ""
"``rname`` provides the field with a “real name”, a name for the field known to "
"the database adapter; when the field is used, it is the rname value which is "
"sent to the database. The py4web name for the field is then effectively an "
"alias."
msgstr ""
"''rname'' fornisce al campo un ''real name'', un nome per il campo noto "
"all'adapter del database; Quando il campo viene utilizzato, è il valore rname "
"che viene inviato al database. Il nome py4web per il campo è quindi "
"effettivamente un alias."

#: ../../chapter-07.rst:951
msgid ""
"``ondelete`` translates into the “ON DELETE” SQL statement. By default it is "
"set to “CASCADE”. This tells the database that when it deletes a record, it "
"should also delete all records that refer to it. To disable this feature, set "
"``ondelete`` to “NO ACTION” or “SET NULL”."
msgstr ""
"''ondelete'' si traduce nell'istruzione SQL ON DELETE. Per impostazione "
"predefinita, è impostato su \"CASCADE\". In questo modo si comunica al database "
"che quando elimina un record, deve eliminare anche tutti i record che vi fanno "
"riferimento. Per disabilitare questa funzione, impostare ''ondelete'' su \"NO "
"ACTION\" o \"SET NULL\"."

#: ../../chapter-07.rst:957
msgid ""
"``notnull=True`` translates into the “NOT NULL” SQL statement. It prevents the "
"database from inserting null values for the field."
msgstr ""
"''notnull=True'' si traduce nell'istruzione SQL \"NOT NULL\". Impedisce al "
"database di inserire valori Null per il campo."

#: ../../chapter-07.rst:960
msgid ""
"``unique=True`` translates into the “UNIQUE” SQL statement and it makes sure "
"that values of this field are unique within the table. It is enforced at the "
"database level."
msgstr ""
"''unique=True'' si traduce nell'istruzione SQL \"UNIQUE\" e fa in modo che i "
"valori di questo campo siano univoci all'interno della tabella. Viene applicato "
"a livello di database."

#: ../../chapter-07.rst:964
msgid ""
"``uploadfield`` applies only to fields of type “upload”. A field of type "
"“upload” stores the name of a file saved somewhere else, by default on the "
"filesystem under the application “uploads/” folder. If ``uploadfield`` is set "
"to True, then the file is stored in a blob field within the same table and the "
"value of ``uploadfield`` is the name of the blob field. This will be discussed "
"in more detail later in `More on uploads`_."
msgstr ""
"''uploadfield'' si applica solo ai campi di tipo \"upload\". Un campo di tipo "
"\"upload\" memorizza il nome di un file salvato da qualche altra parte, per "
"impostazione predefinita sul filesystem nella cartella \"uploads/\" "
"dell'applicazione. Se ''uploadfield'' è impostato su True, il file viene "
"archiviato in un campo BLOB all'interno della stessa tabella e il valore di "
"''uploadfield'' è il nome del campo BLOB. Questo sarà discusso più "
"dettagliatamente più avanti in 'Ulteriori informazioni sui caricamenti'_."

#: ../../chapter-07.rst:971
msgid ""
"``uploadfolder`` must be set to a location where to store uploaded files. The "
"scaffolding app defines a folder ``settings.UPLOAD_FOLDER`` which points to "
"``apps/{app_name}/uploads`` so you can set, for example, ``Field(... "
"uploadfolder=settings.UPLOAD_FOLDER)``."
msgstr ""
"''uploadfolder'' deve essere impostato su una posizione in cui memorizzare i "
"file caricati. L'app di scaffolding definisce una cartella ''impostazioni. "
"UPLOAD_FOLDER'' che punta a ''apps/{app_name}/uploads'' in modo da poter "
"impostare, ad esempio, ''Field(... uploadfolder=impostazioni. UPLOAD_FOLDER)''."

#: ../../chapter-07.rst:975
msgid ""
"``uploadseparate`` if set to True will upload files under different subfolders "
"of the *uploadfolder* folder. This is optimized to avoid too many files under "
"the same folder/subfolder. ATTENTION: You cannot change the value of "
"``uploadseparate`` from True to False without breaking links to existing "
"uploads. pydal either uses the separate subfolders or it does not. Changing the "
"behavior after files have been uploaded will prevent pydal from being able to "
"retrieve those files. If this happens it is possible to move files and fix the "
"problem but this is not described here."
msgstr ""
"''uploadseparate'' se impostato a True caricherà i file in diverse "
"sottocartelle della cartella *uploadfolder*. Questo è ottimizzato per evitare "
"troppi file nella stessa cartella/sottocartella. ATTENZIONE: Non è possibile "
"modificare il valore di ''uploadseparate'' da True a False senza interrompere i "
"collegamenti ai caricamenti esistenti. pydal utilizza le sottocartelle separate "
"o non lo fa. La modifica del comportamento dopo che i file sono stati caricati "
"impedirà a pydal di essere in grado di recuperare tali file. In questo caso, è "
"possibile spostare i file e risolvere il problema, ma questo non è descritto "
"qui."

#: ../../chapter-07.rst:984
msgid ""
"``uploadfs`` allows you specify a different file system where to upload files, "
"including an Amazon S3 storage or a remote SFTP storage."
msgstr ""
"''uploadfs'' consente di specificare un file system diverso in cui caricare i "
"file, incluso uno storage Amazon S3 o uno storage SFTP remoto."

#: ../../chapter-07.rst:990
msgid ""
"You need to have PyFileSystem installed for this to work. ``uploadfs`` must "
"point to PyFileSystem."
msgstr ""
"È necessario che PyFileSystem sia installato affinché funzioni. ''uploadfs'' "
"deve puntare a PyFileSystem."

#: ../../chapter-07.rst:993
msgid ""
"``autodelete`` determines if the corresponding uploaded file should be deleted "
"when the record referencing the file is deleted. For “upload” fields only. "
"However, records deleted by the database itself due to a CASCADE operation will "
"not trigger py4web’s autodelete."
msgstr ""
"''Autodelete'' determina se il file caricato corrispondente deve essere "
"eliminato quando il record che fa riferimento al file viene eliminato. Solo per "
"i campi \"carica\". Tuttavia, i record eliminati dal database stesso a causa di "
"un'operazione CASCADE non attiveranno l'eliminazione automatica di py4web."

#: ../../chapter-07.rst:998
msgid ""
"``label`` is a string (or a helper or something that can be serialized to a "
"string) that contains the label to be used for this field in auto-generated "
"forms. serialized to a string) that contains a comment associated with this "
"field, and will be displayed to the right of the input field in the "
"autogenerated forms."
msgstr ""
"''label'' è una stringa (o un helper o qualcosa che può essere serializzato in "
"una stringa) che contiene l'etichetta da usare per questo campo nei moduli "
"generati automaticamente. serializzato in una stringa) che contiene un commento "
"associato a questo campo e verrà visualizzato a destra del campo di input nei "
"moduli generati automaticamente."

#: ../../chapter-07.rst:1004
msgid "``writable`` declares whether a field is writable in forms."
msgstr "''scrivibile'' dichiara se un campo è scrivibile nelle forme."

#: ../../chapter-07.rst:1005
msgid ""
"``readable`` declares whether a field is readable in forms. If a field is "
"neither readable nor writable, it will not be displayed in create and update "
"forms."
msgstr ""
"''leggibile'' dichiara se un campo è leggibile nei moduli. Se un campo non è né "
"leggibile né scrivibile, non verrà visualizzato nei moduli di creazione e "
"aggiornamento."

#: ../../chapter-07.rst:1008
msgid ""
"``update`` contains the default value for this field when the record is updated."
msgstr ""
"''update'' contiene il valore predefinito per questo campo quando il record "
"viene aggiornato."

#: ../../chapter-07.rst:1010
msgid ""
"``compute`` is an optional function. If a record is inserted or updated, the "
"compute function will be executed and the field will be populated with the "
"function result. The record is passed to the compute function as a ``dict``, "
"and the dict will not include the current value of that, or any other compute "
"field."
msgstr ""
"''compute'' è una funzione opzionale. Se viene inserito o aggiornato un record, "
"la funzione di calcolo verrà eseguita e il campo verrà popolato con il "
"risultato della funzione. Il record viene passato alla funzione di calcolo come "
"''dict'' e il dict non includerà il valore corrente di quello, o di qualsiasi "
"altro campo di calcolo."

#: ../../chapter-07.rst:1015
msgid ""
"``authorize`` can be used to require access control on the corresponding field, "
"for “upload” fields only. It will be discussed more in detail in the context of "
"Authentication and Authorization."
msgstr ""
"''Autorizza'' può essere usato per richiedere il controllo dell'accesso sul "
"campo corrispondente, solo per i campi \"Carica\". Verrà discusso più "
"dettagliatamente nel contesto dell'autenticazione e dell'autorizzazione."

#: ../../chapter-07.rst:1018
msgid ""
"``represent`` can be None or can point to a function that takes a field value "
"and returns an alternate representation for the field value. Examples:"
msgstr ""
"''represent'' può essere None o può puntare a una funzione che accetta un "
"valore di campo e restituisce una rappresentazione alternativa per il valore "
"del campo. Esempi:"

#: ../../chapter-07.rst:1022
msgid ""
"Note not all the attributes are thread safe and most of them should only be set "
"globally for an app. The following are guaranteed to be thread safe and be set/"
"reset in any action: ``default``, ``update``, ``readable``, ``writable``, "
"``requires``."
msgstr ""
"Si noti che non tutti gli attributi sono thread-safe e la maggior parte di essi "
"deve essere impostata solo a livello globale per un'app. I seguenti elementi "
"sono garantiti per essere thread-safe e possono essere impostati/ripristinati "
"in qualsiasi azione: ''default'', ''update'', ''readable'', ''writable'', "
"''requires''."

#: ../../chapter-07.rst:1029
msgid "Field types and validators"
msgstr "Tipi di campo e validatori"

#: ../../chapter-07.rst:1032
msgid "Type"
msgstr "Tipo"

#: ../../chapter-07.rst:1032
msgid "Default validators"
msgstr "Validatori predefiniti"

#: ../../chapter-07.rst:1034
msgid "``string``"
msgstr "''stringa''"

#: ../../chapter-07.rst:1034 ../../chapter-07.rst:1044
msgid "``IS_LENGTH(length)`` default length is 512"
msgstr "''IS_LENGTH(length)'' la lunghezza predefinita è 512"

#: ../../chapter-07.rst:1035
msgid "``text``"
msgstr "''testo''"

#: ../../chapter-07.rst:1035
msgid "``IS_LENGTH(length)`` default length is 32768"
msgstr "La lunghezza predefinita di ''IS_LENGTH(length)'' è 32768"

#: ../../chapter-07.rst:1036
msgid "``blob``"
msgstr "''blob''"

#: ../../chapter-07.rst:1036
msgid "``None`` default length is 2**31 (2 GiB)"
msgstr "La lunghezza predefinita di ''Nessuno'' è 2**31 (2 GiB)"

#: ../../chapter-07.rst:1037
msgid "``boolean``"
msgstr "''booleano''"

#: ../../chapter-07.rst:1037 ../../chapter-07.rst:1047 ../../chapter-07.rst:1048
#: ../../chapter-07.rst:1052 ../../chapter-07.rst:1053
msgid "``None``"
msgstr "''Nessuno''"

#: ../../chapter-07.rst:1038
msgid "``integer``"
msgstr "''intero''"

#: ../../chapter-07.rst:1038
msgid "``IS_INT_IN_RANGE(-2**31, 2**31)``"
msgstr "''IS_INT_IN_RANGE(-2**31, 2**31)''"

#: ../../chapter-07.rst:1039
msgid "``double``"
msgstr "''Doppio''"

#: ../../chapter-07.rst:1039
msgid "``IS_FLOAT_IN_RANGE(-1e100, 1e100)``"
msgstr "''IS_FLOAT_IN_RANGE(-1e100, 1e100)''"

#: ../../chapter-07.rst:1040
msgid "``decimal(n,m)``"
msgstr "''Decimale(N,M)''"

#: ../../chapter-07.rst:1040
msgid "``IS_DECIMAL_IN_RANGE(-10**10, 10**10)``"
msgstr "''IS_DECIMAL_IN_RANGE(-10**10, 10**10)''"

#: ../../chapter-07.rst:1041
msgid "``date``"
msgstr "''data''"

#: ../../chapter-07.rst:1041
msgid "``IS_DATE()``"
msgstr "''IS_DATE()''"

#: ../../chapter-07.rst:1042
msgid "``time``"
msgstr "''Tempo''"

#: ../../chapter-07.rst:1042
msgid "``IS_TIME()``"
msgstr "''IS_TIME()''"

#: ../../chapter-07.rst:1043
msgid "``datetime``"
msgstr "''datetime''"

#: ../../chapter-07.rst:1043
msgid "``IS_DATETIME()``"
msgstr "''IS_DATETIME()''"

#: ../../chapter-07.rst:1044
msgid "``password``"
msgstr "''Parola d'ordine''"

#: ../../chapter-07.rst:1045
msgid "``upload``"
msgstr "''Carica''"

#: ../../chapter-07.rst:1045
msgid "``None`` default length is 512"
msgstr "La lunghezza predefinita di ''None'' è 512"

#: ../../chapter-07.rst:1046
msgid "``reference <table>``"
msgstr "''Riferimento <table>``</table>"

#: ../../chapter-07.rst:1046
msgid "``IS_IN_DB(db, table.field, format)``"
msgstr "''IS_IN_DB(db, tabella.campo, formato)''"

#: ../../chapter-07.rst:1047
msgid "``list:string``"
msgstr "''lista:stringa''"

#: ../../chapter-07.rst:1048
msgid "``list:integer``"
msgstr "''lista:intero''"

#: ../../chapter-07.rst:1049
msgid "``list:reference <table>``"
msgstr "''elenco:riferimento <table>``</table>"

#: ../../chapter-07.rst:1049
msgid "``IS_IN_DB(db, table._id, format, multiple=True)``"
msgstr "''IS_IN_DB(db, table._id, format, multiple=True)''"

#: ../../chapter-07.rst:1050
msgid "``json``"
msgstr "''json''"

#: ../../chapter-07.rst:1050
msgid "``IS_EMPTY_OR(IS_JSON())`` default length is 512"
msgstr "La lunghezza predefinita di ''IS_EMPTY_OR(IS_JSON())'' è 512"

#: ../../chapter-07.rst:1051
msgid "``bigint``"
msgstr "''bigint''"

#: ../../chapter-07.rst:1051
msgid "``IS_INT_IN_RANGE(-2**63, 2**63)``"
msgstr "''IS_INT_IN_RANGE(-2**63, 2**63)''"

#: ../../chapter-07.rst:1052
msgid "``big-id``"
msgstr "''big-id''"

#: ../../chapter-07.rst:1053
msgid "``big-reference``"
msgstr "''big-reference''"

#: ../../chapter-07.rst:1056
msgid ""
"Decimal requires and returns values as ``Decimal`` objects, as defined in the "
"Python ``decimal`` module. SQLite does not handle the ``decimal`` type so "
"internally we treat it as a ``double``. The (n,m) are the number of digits in "
"total and the number of digits after the decimal point respectively."
msgstr ""
"Decimal richiede e restituisce valori come oggetti ''Decimal'', come definito "
"nel modulo ''decimal'' di Python. SQLite non gestisce il tipo ''decimale'', "
"quindi internamente lo trattiamo come un ''double''. (n,m) sono rispettivamente "
"il numero di cifre in totale e il numero di cifre dopo la virgola decimale."

#: ../../chapter-07.rst:1062
msgid ""
"The ``big-id`` and, ``big-reference`` are only supported by some of the "
"database engines and are experimental. They are not normally used as field "
"types unless for legacy tables, however, the DAL constructor has a "
"``bigint_id`` argument that when set to ``True`` makes the ``id`` fields and "
"``reference`` fields ``big-id`` and ``big-reference`` respectively."
msgstr ""
"''big-id'' e ''big-reference'' sono supportati solo da alcuni dei motori di "
"database e sono sperimentali. Non sono normalmente usati come tipi di campo a "
"meno che non siano per le tabelle legacy, tuttavia, il costruttore DAL ha un "
"argomento ''bigint_id'' che quando impostato a ''True'' rende i campi ''id'' e "
"''reference'' campi ''big-id'' e ''big-reference'' rispettivamente."

#: ../../chapter-07.rst:1068
msgid ""
"The ``list:<type>`` fields are special because they are designed to take "
"advantage of certain denormalization features on NoSQL (in the case of Google "
"App Engine NoSQL, the field types ``ListProperty`` and ``StringListProperty``) "
"and back-port them all the other supported relational databases. On relational "
"databases lists are stored as a ``text`` field. The items are separated by a ``|"
"`` and each ``|`` in string item is escaped as a ``||``. They are discussed in :"
"ref:`list_type and contains`."
msgstr ""
"I campi ''list:<type>'' sono speciali perché sono progettati per sfruttare "
"alcune funzionalità di denormalizzazione su NoSQL (nel caso di Google App "
"Engine NoSQL, i tipi di campo ''ListProperty'' e ''StringListProperty'') e back-"
"port di tutti gli altri database relazionali supportati. Nei database "
"relazionali le liste sono memorizzate come campo ''testo''. Gli elementi sono "
"separati da un ''|'' e ogni ''|'' nell'elemento stringa viene preceduto da un "
"carattere di escape ''||``. Sono discussi in :ref:'list_type e contiene'.</type>"

#: ../../chapter-07.rst:1077
msgid ""
"The ``json`` field type is pretty much explanatory. It can store any JSON "
"serializable object. It is designed to work specifically for MongoDB and "
"backported to the other database adapters for portability."
msgstr ""
"Il tipo di campo ''json'' è praticamente esplicativo. Può archiviare qualsiasi "
"oggetto serializzabile JSON. È progettato per funzionare in modo specifico per "
"MongoDB e viene eseguito il backport su altri adattatori di database per la "
"portabilità."

#: ../../chapter-07.rst:1081
msgid ""
"``blob`` fields are also special. By default, binary data is encoded in base64 "
"before being stored into the actual database field, and it is decoded when "
"extracted. This has the negative effect of using 33% more storage space than "
"necessary in blob fields, but has the advantage of making the communication "
"independent of the back-end specific escaping conventions."
msgstr ""
"Anche i campi ''blob'' sono speciali. Per impostazione predefinita, i dati "
"binari vengono codificati in base64 prima di essere archiviati nel campo del "
"database effettivo e vengono decodificati quando vengono estratti. Ciò ha "
"l'effetto negativo di usare il 33% di spazio di archiviazione in più del "
"necessario nei campi BLOB, ma ha il vantaggio di rendere la comunicazione "
"indipendente dalle convenzioni di escape specifiche del back-end."

#: ../../chapter-07.rst:1089
msgid "Run-time field and table modification"
msgstr "Modifica dei campi e delle tabelle in fase di esecuzione"

#: ../../chapter-07.rst:1091
msgid ""
"Most attributes of fields and tables can be modified after they are defined:"
msgstr ""
"La maggior parte degli attributi dei campi e delle tabelle può essere "
"modificata dopo essere stati definiti:"

#: ../../chapter-07.rst:1101
msgid ""
"notice that attributes of tables are usually prefixed by an underscore to avoid "
"conflict with possible field names."
msgstr ""
"Si noti che gli attributi delle tabelle sono in genere preceduti da un "
"carattere di sottolineatura per evitare conflitti con i possibili nomi dei "
"campi."

#: ../../chapter-07.rst:1104
msgid ""
"You can list the tables that have been defined for a given database connection:"
msgstr ""
"È possibile elencare le tabelle definite per una determinata connessione al "
"database:"

#: ../../chapter-07.rst:1112
msgid "You can query for the type of a table:"
msgstr "È possibile eseguire una query per il tipo di tabella:"

#: ../../chapter-07.rst:1119
msgid "You can access a table using different syntaxes:"
msgstr "È possibile accedere a una tabella utilizzando diverse sintassi:"

#: ../../chapter-07.rst:1126
msgid "You can also list the fields that have been defined for a given table:"
msgstr ""
"È inoltre possibile elencare i campi che sono stati definiti per una "
"determinata tabella:"

#: ../../chapter-07.rst:1133
msgid ""
"Similarly you can access fields from their name in multiple equivalent ways:"
msgstr ""
"Allo stesso modo, è possibile accedere ai campi dal loro nome in diversi modi "
"equivalenti:"

#: ../../chapter-07.rst:1143
msgid "Given a field, you can access the attributes set in its definition:"
msgstr ""
"Dato un campo, è possibile accedere agli attributi impostati nella sua "
"definizione:"

#: ../../chapter-07.rst:1156
msgid "including its parent table, tablename, and parent connection:"
msgstr "incluse la tabella padre, il nome della tabella e la connessione padre:"

#: ../../chapter-07.rst:1167
msgid ""
"A field also has methods. Some of them are used to build queries and we will "
"see them later. A special method of the field object is ``validate`` and it "
"calls the validators for the field."
msgstr ""
"Un campo ha anche dei metodi. Alcuni di essi vengono utilizzati per creare "
"query e li vedremo più avanti. Un metodo speciale dell'oggetto campo è "
"''validate'' e chiama i validatori per il campo."

#: ../../chapter-07.rst:1176
msgid ""
"which returns a tuple ``(value, error)``. ``error`` is ``None`` if the input "
"passes validation."
msgstr ""
"che restituisce una tupla ''(valore, errore)''. ''error'' è ''None'' se l'input "
"supera la convalida."

#: ../../chapter-07.rst:1180
msgid "More on uploads"
msgstr "Ulteriori informazioni sui caricamenti"

#: ../../chapter-07.rst:1184
msgid "Consider the following model:"
msgstr "Si consideri il seguente modello:"

#: ../../chapter-07.rst:1191
msgid ""
"In the case of an “upload” field, the default value can optionally be set to a "
"path (an absolute path or a path relative to the current app folder), the "
"default value is then assigned to each new record that does not specify an "
"image."
msgstr ""
"Nel caso di un campo \"carica\", il valore predefinito può essere "
"facoltativamente impostato su un percorso (un percorso assoluto o un percorso "
"relativo alla cartella dell'app corrente), il valore predefinito viene quindi "
"assegnato a ogni nuovo record che non specifica un'immagine."

#: ../../chapter-07.rst:1196
msgid ""
"Notice that this way multiple records may end to reference the same default "
"image file and this could be a problem on a Field having ``autodelete`` "
"enabled. When you do not want to allow duplicates for the image field (i."
"e. multiple records referencing the same file) but still want to set a default "
"value for the “upload” then you need a way to copy the default file for each "
"new record that does not specify an image. This can be obtained using a file-"
"like object referencing the default file as the ``default`` argument to Field, "
"or even with:"
msgstr ""
"Si noti che in questo modo più record potrebbero finire per fare riferimento "
"allo stesso file immagine predefinito e questo potrebbe essere un problema su "
"un campo con ''autodelete'' abilitato. Quando non si desidera consentire "
"duplicati per il campo immagine (ad esempio, più record che fanno riferimento "
"allo stesso file) ma si desidera comunque impostare un valore predefinito per "
"il \"caricamento\", è necessario un modo per copiare il file predefinito per "
"ogni nuovo record che non specifica un'immagine. Questo può essere ottenuto "
"usando un oggetto simile a un file che fa riferimento al file predefinito come "
"argomento ''default'' di Field, o anche con:"

#: ../../chapter-07.rst:1209
msgid ""
"Normally an insert is handled automatically via a ``Form`` but occasionally you "
"already have the file on the filesystem and want to upload it programmatically. "
"This can be done in this way:"
msgstr ""
"Normalmente un inserimento viene gestito automaticamente tramite un ''Form'', "
"ma occasionalmente si ha già il file sul filesystem e si vuole caricarlo "
"programmaticamente. Questo può essere fatto in questo modo:"

#: ../../chapter-07.rst:1218
msgid ""
"It is also possible to insert a file in a simpler way and have the insert "
"method call ``store`` automatically:"
msgstr ""
"E' anche possibile inserire un file in modo più semplice e fare in modo che il "
"metodo insert chiami ''store'' automaticamente:"

#: ../../chapter-07.rst:1226
msgid "In this case the filename is obtained from the stream object if available."
msgstr ""
"In questo caso, il nome del file viene ottenuto dall'oggetto stream, se "
"disponibile."

#: ../../chapter-07.rst:1229
msgid ""
"The ``store`` method of the upload field object takes a file stream and a "
"filename. It uses the filename to determine the extension (type) of the file, "
"creates a new temp name for the file (according to py4web upload mechanism) and "
"loads the file content in this new temp file (under the uploads folder unless "
"specified otherwise). It returns the new temp name, which is then stored in the "
"``image`` field of the ``db.myfile`` table."
msgstr ""
"Il metodo ''store'' dell'oggetto campo di caricamento accetta un flusso di file "
"e un nome di file. Utilizza il nome del file per determinare l'estensione "
"(tipo) del file, crea un nuovo nome temporaneo per il file (in base al "
"meccanismo di caricamento py4web) e carica il contenuto del file in questo "
"nuovo file temporaneo (nella cartella uploads se non diversamente specificato). "
"Restituisce il nuovo nome temporaneo, che viene poi memorizzato nel campo "
"''image'' della tabella ''db.myfile''."

#: ../../chapter-07.rst:1237
msgid ""
"Note, if the file is to be stored in an associated blob field rather than the "
"file system, the ``store`` method will not insert the file in the blob field "
"(because ``store`` is called before the insert), so the file must be explicitly "
"inserted into the blob field:"
msgstr ""
"Si noti che, se il file deve essere archiviato in un campo BLOB associato "
"anziché nel file system, il metodo ''store'' non inserirà il file nel campo "
"BLOB (perché ''store'' viene chiamato prima dell'inserimento), quindi il file "
"deve essere inserito in modo esplicito nel campo BLOB:"

#: ../../chapter-07.rst:1251
msgid "The ``retrieve`` method does the opposite of ``store``."
msgstr "Il metodo ''retrieve'' fa l'opposto di ''store''."

#: ../../chapter-07.rst:1253
msgid ""
"When uploaded files are stored on filesystem (as in the case of a plain "
"``Field('image', 'upload')``) the code:"
msgstr ""
"Quando i file caricati sono memorizzati sul filesystem (come nel caso di un "
"semplice ''Field('image', 'upload')'') il codice:"

#: ../../chapter-07.rst:1261
msgid ""
"retrieves the original file name (filename) as seen by the user at upload time "
"and the name of stored file (fullname, with path relative to application "
"folder). While in general the call:"
msgstr ""
"Recupera il nome del file originale (filename) visto dall'utente al momento del "
"caricamento e il nome del file memorizzato (fullname, con percorso relativo "
"alla cartella dell'applicazione). Mentre in generale l'invito:"

#: ../../chapter-07.rst:1269
msgid ""
"retrieves the original file name (filename) and a file-like object ready to "
"access uploaded file data (stream)."
msgstr ""
"Recupera il nome del file originale (filename) e un oggetto simile a un file "
"pronto per accedere ai dati del file caricato (flusso)."

#: ../../chapter-07.rst:1272
msgid ""
"Notice that the stream returned by ``retrieve`` is a real file object in the "
"case that uploaded files are stored on filesystem. In that case remember to "
"close the file when you are done, calling ``stream.close()``."
msgstr ""
"Si noti che il flusso restituito da ''retrieve'' è un oggetto file reale nel "
"caso in cui i file caricati siano memorizzati sul filesystem. In tal caso "
"ricordati di chiudere il file quando hai finito, chiamando ''stream.close()''."

#: ../../chapter-07.rst:1277
msgid "Here is an example of safe usage of ``retrieve``:"
msgstr "Ecco un esempio di utilizzo sicuro di ''retrieve'':"

#: ../../chapter-07.rst:1290
msgid "Migrations"
msgstr "Migrazioni"

#: ../../chapter-07.rst:1292
msgid "With our example table definition:"
msgstr "Con la nostra definizione di tabella di esempio:"

#: ../../chapter-07.rst:1298
msgid ""
"``define_table`` checks whether or not the corresponding table exists. If it "
"does not, it generates the SQL to create it and executes the SQL. If the table "
"does exist but differs from the one being defined, it generates the SQL to "
"alter the table and executes it. If a field has changed type but not name, it "
"will try to convert the data (If you do not want this, you need to redefine the "
"table twice, the first time, letting py4web drop the field by removing it, and "
"the second time adding the newly defined field so that py4web can create it). "
"If the table exists and matches the current definition, it will leave it alone. "
"In all cases it will create the ``db.person`` object that represents the table."
msgstr ""
"''define_table'' controlla se la tabella corrispondente esiste o meno. In caso "
"contrario, genera l'SQL per crearlo ed esegue l'SQL. Se la tabella esiste ma è "
"diversa da quella definita, genera l'SQL per modificare la tabella e lo esegue. "
"Se un campo ha cambiato tipo ma non nome, cercherà di convertire i dati (se non "
"lo si desidera, è necessario ridefinire la tabella due volte, la prima volta, "
"lasciando che py4web elimini il campo rimuovendolo, e la seconda volta "
"aggiungendo il campo appena definito in modo che py4web possa crearlo). Se la "
"tabella esiste e corrisponde alla definizione corrente, verrà lasciata "
"invariata. In tutti i casi creerà l'oggetto ''db.person'' che rappresenta la "
"tabella."

#: ../../chapter-07.rst:1310
msgid ""
"We refer to this behavior as a “migration”. py4web logs all migrations and "
"migration attempts in the file “sql.log”."
msgstr ""
"Ci riferiamo a questo comportamento come \"migrazione\". py4web registra tutte "
"le migrazioni e i tentativi di migrazione nel file \"sql.log\"."

#: ../../chapter-07.rst:1315
msgid ""
"by default py4web uses the “app/databases” folder for the log file and all "
"other migration files it needs. You can change this setting by changing the "
"``folder`` argument to DAL. To set a different log file name, for example "
"“migrate.log” you can do ``db = DAL(..., adapter_args=dict(logfile='migrate."
"log'))``"
msgstr ""
"Per impostazione predefinita, py4web utilizza la cartella \"App/Databases\" per "
"il file di log e tutti gli altri file di migrazione necessari. È possibile "
"modificare questa impostazione cambiando l'argomento ''folder'' in DAL. Per "
"impostare un nome diverso per il file di log, ad esempio \"migrate.log\" si può "
"fare ''db = DAL(..., adapter_args=dict(logfile='migrate.log'))''"

#: ../../chapter-07.rst:1321
msgid ""
"The first argument of ``define_table`` is always the table name. The other "
"unnamed arguments are the fields. The function also takes an optional keyword "
"argument called “migrate”:"
msgstr ""
"Il primo argomento di ''define_table'' è sempre il nome della tabella. Gli "
"altri argomenti senza nome sono i campi. La funzione accetta anche un argomento "
"di parola chiave facoltativo chiamato \"migrate\":"

#: ../../chapter-07.rst:1329
msgid ""
"The value of migrate is the filename where py4web stores internal migration "
"information for this table. These files are very important and should never be "
"removed while the corresponding tables exist. In cases where a table has been "
"dropped and the corresponding file still exist, it can be removed manually. By "
"default, migrate is set to True. This causes py4web to generate the filename "
"from a hash of the connection string. If migrate is set to False, the migration "
"is not performed, and py4web assumes that the table exists in the datastore and "
"it contains (at least) the fields listed in ``define_table``."
msgstr ""
"Il valore di migrate è il nome del file in cui py4web memorizza le informazioni "
"di migrazione interne per questa tabella. Questi file sono molto importanti e "
"non dovrebbero mai essere rimossi mentre esistono le tabelle corrispondenti. "
"Nei casi in cui una tabella è stata eliminata e il file corrispondente esiste "
"ancora, può essere rimosso manualmente. Per impostazione predefinita, la "
"migrazione è impostata su True. Questo fa sì che py4web generi il nome del file "
"da un hash della stringa di connessione. Se migrate è impostato su False, la "
"migrazione non viene eseguita e py4web assume che la tabella esista nel "
"datastore e contenga (almeno) i campi elencati in ''define_table''."

#: ../../chapter-07.rst:1339
msgid ""
"There may not be two tables in the same application with the same migrate "
"filename."
msgstr ""
"È possibile che nella stessa applicazione non siano presenti due tabelle con lo "
"stesso nome file di migrazione."

#: ../../chapter-07.rst:1342
msgid ""
"The DAL class also takes a “migrate” argument, which determines the default "
"value of migrate for calls to ``define_table``. For example,"
msgstr ""
"La classe DAL accetta anche un argomento \"migrate\", che determina il valore "
"predefinito di migrate per le chiamate a ''define_table''. Per esempio"

#: ../../chapter-07.rst:1349
msgid ""
"will set the default value of migrate to False whenever ``db.define_table`` is "
"called without a migrate argument."
msgstr ""
"imposterà il valore predefinito di migrate a False ogni volta che ''db."
"define_table'' viene chiamato senza un argomento di migrazione."

#: ../../chapter-07.rst:1354
msgid ""
"py4web only migrates new columns, removed columns, and changes in column type "
"(except in SQLite). py4web does not migrate changes in attributes such as "
"changes in the values of ``default``, ``unique``, ``notnull``, and ``ondelete``."
msgstr ""
"py4web esegue solo la migrazione di nuove colonne, colonne rimosse e modifiche "
"nel tipo di colonna (tranne che in SQLite). py4web non migra le modifiche negli "
"attributi come le modifiche nei valori di ''default'', ''unique'', ''notnull'' "
"e ''ondelete''."

#: ../../chapter-07.rst:1359
msgid "Migrations can be disabled for all tables at once:"
msgstr ""
"Le migrazioni possono essere disabilitate per tutte le tabelle "
"contemporaneamente:"

#: ../../chapter-07.rst:1365
msgid ""
"This is the recommended behavior when two apps share the same database. Only "
"one of the two apps should perform migrations, the other should disable them."
msgstr ""
"Questo è il comportamento consigliato quando due app condividono lo stesso "
"database. Solo una delle due app deve eseguire le migrazioni, l'altra deve "
"disabilitarle."

#: ../../chapter-07.rst:1370
msgid "Fixing broken migrations"
msgstr "Correzione delle migrazioni interrotte"

#: ../../chapter-07.rst:1372
msgid ""
"There are two common problems with migrations and there are ways to recover "
"from them."
msgstr ""
"Ci sono due problemi comuni con le migrazioni e ci sono modi per riprendersi da "
"esse."

#: ../../chapter-07.rst:1375
msgid ""
"One problem is specific with SQLite. SQLite does not enforce column types and "
"cannot drop columns. This means that if you have a column of type string and "
"you remove it, it is not really removed. If you add the column again with a "
"different type (for example datetime) you end up with a datetime column that "
"contains strings (junk for practical purposes). py4web does not complain about "
"this because it does not know what is in the database, until it tries to "
"retrieve records and fails."
msgstr ""
"Un problema è specifico con SQLite. SQLite non applica i tipi di colonna e non "
"può eliminare le colonne. Ciò significa che se si dispone di una colonna di "
"tipo string e la si rimuove, non viene effettivamente rimossa. Se si aggiunge "
"di nuovo la colonna con un tipo diverso (ad esempio datetime), si ottiene una "
"colonna datetime che contiene stringhe (spazzatura per scopi pratici). py4web "
"non si lamenta di questo perché non sa cosa c'è nel database, fino a quando non "
"tenta di recuperare i record e fallisce."

#: ../../chapter-07.rst:1383
msgid ""
"If py4web returns an error in some parse function when selecting records, most "
"likely this is due to corrupted data in a column because of the above issue."
msgstr ""
"Se py4web restituisce un errore in una funzione di analisi durante la selezione "
"dei record, molto probabilmente ciò è dovuto a dati danneggiati in una colonna "
"a causa del problema di cui sopra."

#: ../../chapter-07.rst:1387
msgid ""
"The solution consists in updating all records of the table and updating the "
"values in the column in question with None."
msgstr ""
"La soluzione consiste nell'aggiornare tutti i record della tabella e aggiornare "
"i valori nella colonna in questione con None."

#: ../../chapter-07.rst:1390
msgid ""
"The other problem is more generic but typical with MySQL. MySQL does not allow "
"more than one ALTER TABLE in a transaction. This means that py4web must break "
"complex transactions into smaller ones (one ALTER TABLE at the time) and commit "
"one piece at the time. It is therefore possible that part of a complex "
"transaction gets committed and one part fails, leaving py4web in a corrupted "
"state. Why would part of a transaction fail? Because, for example, it involves "
"altering a table and converting a string column into a datetime column, py4web "
"tries to convert the data, but the data cannot be converted. What happens to "
"py4web? It gets confused about what exactly is the table structure actually "
"stored in the database."
msgstr ""
"L'altro problema è più generico ma tipico di MySQL. MySQL non consente più di "
"un ALTER TABLE in una transazione. Ciò significa che py4web deve suddividere le "
"transazioni complesse in transazioni più piccole (un ALTER TABLE alla volta) e "
"fare un commit alla volta. È quindi possibile che una parte di una transazione "
"complessa venga salvata e una parte fallisca, lasciando py4web in uno stato "
"corrotto. Perché una parte di una transazione non riesce? Poiché, ad esempio, "
"comporta la modifica di una tabella e la conversione di una colonna stringa in "
"una colonna datetime, py4web tenta di convertire i dati, ma i dati non possono "
"essere convertiti. Cosa succede a py4web? Si confonde su quale sia esattamente "
"la struttura della tabella effettivamente memorizzata nel database."

#: ../../chapter-07.rst:1402
msgid "The solution consists of enabling fake migrations:"
msgstr "La soluzione consiste nell'abilitare false migrazioni:"

#: ../../chapter-07.rst:1408
msgid ""
"This will rebuild py4web metadata about the table according to the table "
"definition. Try multiple table definitions to see which one works (the one "
"before the failed migration and the one after the failed migration). Once "
"successful remove the ``fake_migrate=True`` parameter."
msgstr ""
"In questo modo verranno ricostruiti i metadati py4web relativi alla tabella in "
"base alla definizione della tabella. Provare più definizioni di tabella per "
"vedere quale funziona (quella prima della migrazione non riuscita e quella dopo "
"la migrazione non riuscita). Una volta riuscito, rimuovere il parametro "
"''fake_migrate=True''."

#: ../../chapter-07.rst:1413
msgid ""
"Before attempting to fix migration problems it is prudent to make a copy of "
"“yourapp/databases/\\*.table” files."
msgstr ""
"Prima di tentare di risolvere i problemi di migrazione, è prudente creare una "
"copia dei file \"yourapp/databases/\\*.table\"."

#: ../../chapter-07.rst:1416
msgid "Migration problems can also be fixed for all tables at once:"
msgstr ""
"I problemi di migrazione possono anche essere risolti per tutte le tabelle "
"contemporaneamente:"

#: ../../chapter-07.rst:1422
msgid ""
"This also fails if the model describes tables that do not exist in the "
"database, but it can help narrowing down the problem."
msgstr ""
"Questa operazione ha esito negativo anche se il modello descrive tabelle che "
"non esistono nel database, ma può aiutare a restringere il problema."

#: ../../chapter-07.rst:1426
msgid "Migration control summary"
msgstr "Riepilogo del controllo della migrazione"

#: ../../chapter-07.rst:1428
msgid ""
"The logic of the various migration arguments are summarized in this pseudo-code:"
msgstr ""
"La logica dei vari argomenti di migrazione è riassunta in questo pseudo-codice:"

#: ../../chapter-07.rst:1441
msgid "Table methods"
msgstr "Metodi di tabella"

#: ../../chapter-07.rst:1444
msgid "``insert``"
msgstr "''inserisci''"

#: ../../chapter-07.rst:1446
msgid "Given a table, you can insert records"
msgstr "Data una tabella, è possibile inserire record"

#: ../../chapter-07.rst:1455
msgid "Insert returns the unique “id” value of each record inserted."
msgstr "Inserisci restituisce il valore \"id\" univoco di ogni record inserito."

#: ../../chapter-07.rst:1457
msgid ""
"You can truncate the table, i.e., delete all records and reset the counter of "
"the id."
msgstr ""
"È possibile troncare la tabella, ovvero eliminare tutti i record e reimpostare "
"il contatore dell'id."

#: ../../chapter-07.rst:1464
msgid ""
"Now, if you insert a record again, the counter starts again at 1 (this is back-"
"end specific and does not apply to Google NoSQL):"
msgstr ""
"Ora, se inserisci di nuovo un record, il contatore ricomincia da 1 (questo è "
"specifico del back-end e non si applica a Google NoSQL):"

#: ../../chapter-07.rst:1472
msgid ""
"Notice you can pass a parameter to ``truncate``, for example you can tell "
"SQLite to restart the id counter."
msgstr ""
"Si noti che si può passare un parametro a ''truncate'', ad esempio si può dire "
"a SQLite di riavviare il contatore id."

#: ../../chapter-07.rst:1479
msgid "The argument is in raw SQL and therefore engine specific."
msgstr "L'argomento è in SQL non elaborato e quindi specifico del motore."

#: ../../chapter-07.rst:1481
msgid "py4web also provides a bulk_insert method"
msgstr "py4web fornisce anche un metodo bulk_insert"

#: ../../chapter-07.rst:1488
msgid ""
"It takes a list of dictionaries of fields to be inserted and performs multiple "
"inserts at once. It returns the list of “id” values of the inserted records. On "
"the supported relational databases there is no advantage in using this function "
"as opposed to looping and performing individual inserts but on Google App "
"Engine NoSQL, there is a major speed advantage."
msgstr ""
"Richiede un elenco di dizionari di campi da inserire ed esegue più inserimenti "
"contemporaneamente. Restituisce l'elenco dei valori \"id\" dei record inseriti. "
"Sui database relazionali supportati non c'è alcun vantaggio nell'utilizzo di "
"questa funzione rispetto al looping e all'esecuzione di singoli inserimenti, ma "
"su Google App Engine NoSQL c'è un grande vantaggio in termini di velocità."

#: ../../chapter-07.rst:1496
msgid "``Query``, ``Set``, ``Rows``"
msgstr "''Interrogazione'', ''Imposta'', ''Righe''"

#: ../../chapter-07.rst:1498
msgid ""
"Let’s consider again the table defined (and dropped) previously and insert "
"three records:"
msgstr ""
"Consideriamo nuovamente la tabella definita (e eliminata) in precedenza e "
"inseriamo tre record:"

#: ../../chapter-07.rst:1512
msgid ""
"You can store the table in a variable. For example, with variable ``person``, "
"you could do:"
msgstr ""
"È possibile memorizzare la tabella in una variabile. Ad esempio, con la "
"variabile ''person'', si potrebbe fare:"

#: ../../chapter-07.rst:1519
msgid ""
"You can also store a field in a variable such as ``name``. For example, you "
"could also do:"
msgstr ""
"Puoi anche memorizzare un campo in una variabile come ''name''. Ad esempio, "
"potresti anche fare:"

#: ../../chapter-07.rst:1526
msgid ""
"You can even build a query (using operators like ==, !=, <, >, <=, >=, like, "
"belongs) and store the query in a variable ``q`` such as in:"
msgstr ""
"È anche possibile creare una query (usando operatori come ==, !=, <, >, <=, >=, "
"like, belongs) e memorizzare la query in una variabile ''q'' come in:"

#: ../../chapter-07.rst:1533
msgid ""
"When you call ``db`` with a query, you define a set of records. You can store "
"it in a variable ``s`` and write:"
msgstr ""
"Quando si chiama ''db'' con una query, si definisce un insieme di record. Puoi "
"memorizzarlo in una variabile ''s'' e scrivere:"

#: ../../chapter-07.rst:1540
msgid ""
"Notice that no database query has been performed so far. DAL + Query simply "
"define a set of records in this db that match the query. py4web determines from "
"the query which table (or tables) are involved and, in fact, there is no need "
"to specify that."
msgstr ""
"Si noti che finora non è stata eseguita alcuna query di database. DAL + Query "
"definisce semplicemente un insieme di record in questo db che corrispondono "
"alla query. py4web determina dalla query quale tabella (o tabelle) sono "
"coinvolte e, di fatto, non c'è bisogno di specificarlo."

#: ../../chapter-07.rst:1546
msgid "``update_or_insert``"
msgstr "''update_or_insert''"

#: ../../chapter-07.rst:1548
msgid ""
"Some times you need to perform an insert only if there is no record with the "
"same values as those being inserted. This can be done with"
msgstr ""
"A volte è necessario eseguire un inserimento solo se non è presente alcun "
"record con gli stessi valori di quelli inseriti. Questo può essere fatto con"

#: ../../chapter-07.rst:1559
msgid ""
"The record will be inserted only if there is no other user called John born in "
"Chicago."
msgstr ""
"Il record verrà inserito solo se non c'è nessun altro utente di nome John nato "
"a Chicago."

#: ../../chapter-07.rst:1562
msgid ""
"You can specify which values to use as a key to determine if the record exists. "
"For example:"
msgstr ""
"È possibile specificare i valori da utilizzare come chiave per determinare se "
"il record esiste. Per esempio:"

#: ../../chapter-07.rst:1571
msgid ""
"and if there is John his birthplace will be updated else a new record will be "
"created."
msgstr ""
"e se c'è Giovanni, il suo luogo di nascita verrà aggiornato, altrimenti verrà "
"creato un nuovo record."

#: ../../chapter-07.rst:1574
msgid ""
"The selection criteria in the example above is a single field. It can also be a "
"query, such as"
msgstr ""
"Il criterio di selezione nell'esempio precedente è un singolo campo. Può anche "
"essere una query, ad esempio"

#: ../../chapter-07.rst:1585
msgid "``validate_and_insert``, ``validate_and_update``"
msgstr "''validate_and_insert'', ''validate_and_update''"

#: ../../chapter-07.rst:1587
msgid "The function"
msgstr "La funzione"

#: ../../chapter-07.rst:1593
msgid "works very much like"
msgstr "funziona in modo molto simile"

#: ../../chapter-07.rst:1599
msgid ""
"except that it calls the validators for the fields before performing the insert "
"and bails out if the validation does not pass. If validation does not pass the "
"errors can be found in ``ret[\"errors\"]``. ``ret[\"errors\"]`` holds a key-"
"value mapping where each key is the field name whose validation failed, and the "
"value of the key is the result from the validation error (much like "
"``form[\"errors\"]``). If it passes, the id of the new record is in "
"``ret[\"id\"]``. Mind that normally validation is done by the form processing "
"logic so this function is rarely needed."
msgstr ""
"tranne per il fatto che chiama i validatori per i campi prima di eseguire "
"l'inserimento e si salva se la convalida non viene superata. Se la convalida "
"non ha esito positivo, gli errori possono essere trovati in "
"''ret[\"errors\"]''. ''ret[\"errors\"]'' contiene una mappatura chiave-valore "
"in cui ogni chiave è il nome del campo la cui convalida non è riuscita, e il "
"valore della chiave è il risultato dell'errore di convalida (molto simile a "
"''form[\"errors\"]''). Se passa, l'id del nuovo record è in ''ret[\"id\"]''. "
"Tieni presente che normalmente la convalida viene eseguita dalla logica di "
"elaborazione del modulo, quindi questa funzione è raramente necessaria."

#: ../../chapter-07.rst:1608
msgid "Similarly"
msgstr "Similmente"

#: ../../chapter-07.rst:1614
msgid "works very much the same as"
msgstr "funziona molto allo stesso modo di"

#: ../../chapter-07.rst:1620
msgid ""
"except that it calls the validators for the fields before performing the "
"update. Notice that it only works if query involves a single table. The number "
"of updated records can be found in ``ret[\"updated\"]`` and errors will be in "
"``ret[\"errors\"]``."
msgstr ""
"tranne per il fatto che chiama i validatori per i campi prima di eseguire "
"l'aggiornamento. Si noti che funziona solo se la query coinvolge una singola "
"tabella. Il numero di record aggiornati può essere trovato in "
"''ret[\"updated\"]'' e gli errori saranno in ''ret[\"errors\"]''."

#: ../../chapter-07.rst:1626
msgid "``drop``"
msgstr "''goccia''"

#: ../../chapter-07.rst:1628
msgid "Finally, you can drop tables and all data will be lost:"
msgstr "Infine, è possibile eliminare le tabelle e tutti i dati andranno persi:"

#: ../../chapter-07.rst:1635
msgid "Tagging records"
msgstr "Assegnazione di tag ai record"

#: ../../chapter-07.rst:1637
msgid ""
"Tags allows to add or find properties attached to records in your database."
msgstr ""
"Tag consente di aggiungere o trovare proprietà associate ai record nel database."

#: ../../chapter-07.rst:1667
msgid ""
"It is internally implemented as a table, which in this example would be db."
"thing_tags_default, because no tail was specified on the Tags(table, "
"tail=“default”) constructor."
msgstr ""
"Viene implementato internamente come tabella, che in questo esempio sarebbe db."
"thing_tags_default, perché non è stata specificata alcuna coda nel costruttore "
"Tags(table, tail=\"default\")."

#: ../../chapter-07.rst:1671
msgid ""
"The ``find`` method is doing a search by ``startswith`` of the parameter. Then "
"find([“color”]) would return id1 and id2 because both records have tags "
"starting with “color”. py4web uses tags as a flexible mechanism to manage "
"permissions."
msgstr ""
"Il metodo ''find'' consiste nell'eseguire una ricerca per ''startswith'' del "
"parametro. Quindi find([\"color\"]) restituirebbe id1 e id2 perché entrambi i "
"record hanno tag che iniziano con \"color\". py4web utilizza i tag come "
"meccanismo flessibile per gestire le autorizzazioni."

#: ../../chapter-07.rst:1678
msgid "Raw SQL"
msgstr "SQL non elaborato"

#: ../../chapter-07.rst:1681
msgid "``executesql``"
msgstr "''ExecuteSQL''"

#: ../../chapter-07.rst:1683
msgid "The DAL allows you to explicitly issue SQL statements."
msgstr "Il DAL consente di emettere in modo esplicito istruzioni SQL."

#: ../../chapter-07.rst:1690
msgid ""
"In this case, the return values are not parsed or transformed by the DAL, and "
"the format depends on the specific database driver. This usage with selects is "
"normally not needed, but it is more common with indexes."
msgstr ""
"In questo caso, i valori restituiti non vengono analizzati o trasformati dal "
"DAL e il formato dipende dal driver di database specifico. Questo utilizzo con "
"le selezioni non è normalmente necessario, ma è più comune con gli indici."

#: ../../chapter-07.rst:1694
msgid ""
"``executesql`` takes five optional arguments: ``placeholders``, ``as_dict``, "
"``fields``, ``colnames``, and ``as_ordered_dict``."
msgstr ""
"''ExecuteSQL'' accetta cinque argomenti facoltativi: ''Segnaposto'', "
"''as_dict'', ''Campi'', ''Colnames'' e ''as_ordered_dict''."

#: ../../chapter-07.rst:1697
msgid ""
"``placeholders`` is an optional sequence of values to be substituted in or, if "
"supported by the DB driver, a dictionary with keys matching named placeholders "
"in your SQL."
msgstr ""
"''placeholders'' è una sequenza opzionale di valori da sostituire o, se "
"supportato dal driver DB, un dizionario con chiavi corrispondenti ai segnaposto "
"nominati nel tuo SQL."

#: ../../chapter-07.rst:1701
msgid ""
"If ``as_dict`` is set to True, the results cursor returned by the DB driver "
"will be converted to a sequence of dictionaries keyed with the db field names. "
"Results returned with ``as_dict = True`` are the same as those returned when "
"applying as_list() to a normal select:"
msgstr ""
"Se ''as_dict'' è impostato su True, il cursore dei risultati restituito dal "
"driver DB verrà convertito in una sequenza di dizionari digitati con i nomi dei "
"campi db. I risultati restituiti con ''as_dict = True'' sono gli stessi di "
"quelli restituiti quando si applica as_list() ad una selezione normale:"

#: ../../chapter-07.rst:1710
msgid ""
"``as_ordered_dict`` is pretty much like ``as_dict`` but the former ensures that "
"the order of resulting fields (OrderedDict keys) reflect the order on which "
"they are returned from DB driver:"
msgstr ""
"''as_ordered_dict'' è molto simile a ''as_dict'', ma il primo assicura che "
"l'ordine dei campi risultanti (chiavi OrderedDict) rifletta l'ordine in cui "
"vengono restituiti dal driver DB:"

#: ../../chapter-07.rst:1719
msgid ""
"The ``fields`` argument is a list of DAL Field objects that match the fields "
"returned from the DB. The Field objects should be part of one or more Table "
"objects defined on the DAL object. The ``fields`` list can include one or more "
"DAL Table objects in addition to or instead of including Field objects, or it "
"can be just a single table (not in a list). In that case, the Field objects "
"will be extracted from the table(s)."
msgstr ""
"L'argomento ''fields'' è un elenco di oggetti DAL Field che corrispondono ai "
"campi restituiti dal DB. Gli oggetti Field devono far parte di uno o più "
"oggetti Table definiti nell'oggetto DAL. L'elenco ''fields'' può includere uno "
"o più oggetti DAL Table in aggiunta o al posto di includere oggetti Field, "
"oppure può essere solo una singola tabella (non in una lista). In tal caso, gli "
"oggetti Field verranno estratti dalle tabelle."

#: ../../chapter-07.rst:1727
msgid ""
"Instead of specifying the ``fields`` argument, the ``colnames`` argument can be "
"specified as a list of field names in tablename.fieldname format. Again, these "
"should represent tables and fields defined on the DAL object."
msgstr ""
"Invece di specificare l'argomento ''fields'', l'argomento ''colnames'' può "
"essere specificato come un elenco di nomi di campo nel formato nometabella."
"nomecampo. Anche in questo caso, questi devono rappresentare tabelle e campi "
"definiti nell'oggetto DAL."

#: ../../chapter-07.rst:1732
msgid ""
"It is also possible to specify both ``fields`` and the associated ``colnames``. "
"In that case, ``fields`` can also include DAL Expression objects in addition to "
"Field objects. For Field objects in “fields”, the associated ``colnames`` must "
"still be in tablename.fieldname format. For Expression objects in ``fields``, "
"the associated ``colnames`` can be any arbitrary labels."
msgstr ""
"E' anche possibile specificare sia i ''campi'' che i ''colnames'' associati. In "
"tal caso, ''fields'' può includere anche oggetti DAL Expression oltre agli "
"oggetti Field. Per gli oggetti Campo in \"campi\", i ''nomicol'' associati "
"devono essere ancora nel formato nometabella.nomecampo. Per gli oggetti "
"Expression in ''fields'', i ''colnames'' associati possono essere qualsiasi "
"etichetta arbitraria."

#: ../../chapter-07.rst:1739
msgid ""
"Notice, the DAL Table objects referred to by ``fields`` or ``colnames`` can be "
"dummy tables and do not have to represent any real tables in the database. "
"Also, note that the ``fields`` and ``colnames`` must be in the same order as "
"the fields in the results cursor returned from the DB."
msgstr ""
"Si noti che gli oggetti DAL Table a cui si fa riferimento con ''fields'' o "
"''colnames'' possono essere tabelle fittizie e non devono rappresentare alcuna "
"tabella reale nel database. Inoltre, si noti che i ''campi'' e i ''colnames'' "
"devono essere nello stesso ordine dei campi nel cursore dei risultati "
"restituito dal DB."

#: ../../chapter-07.rst:1745
msgid "``_lastsql``"
msgstr "''_lastsql''"

#: ../../chapter-07.rst:1747
msgid ""
"Whether SQL was executed manually using executesql or was SQL generated by the "
"DAL, you can always find the SQL code in ``db._lastsql``. This is useful for "
"debugging purposes:"
msgstr ""
"Sia che SQL sia stato eseguito manualmente usando executesql o che sia stato "
"generato dal DAL, è sempre possibile trovare il codice SQL in ''db._lastsql''. "
"Ciò è utile a scopo di debug:"

#: ../../chapter-07.rst:1759
msgid ""
"py4web never generates queries using the “*” operator. py4web is always "
"explicit when selecting fields."
msgstr ""
"py4web non genera mai query utilizzando l'operatore \"*\". py4web è sempre "
"esplicito quando si selezionano i campi."

#: ../../chapter-07.rst:1763
msgid "Timing queries"
msgstr "Query di temporizzazione"

#: ../../chapter-07.rst:1765
msgid ""
"All queries are automatically timed by py4web. The variable ``db._timings`` is "
"a list of tuples. Each tuple contains the raw SQL query as passed to the "
"database driver and the time it took to execute in seconds."
msgstr ""
"Tutte le query sono temporizzate automaticamente da py4web. La variabile ''db."
"_timings'' è una lista di tuple. Ogni tupla contiene la query SQL non elaborata "
"passata al driver di database e il tempo necessario per l'esecuzione in secondi."

#: ../../chapter-07.rst:1771
msgid "Indexes"
msgstr "Indici"

#: ../../chapter-07.rst:1773
msgid ""
"Currently the DAL API does not provide a command to create indexes on tables, "
"but this can be done using the ``executesql`` command. This is because the "
"existence of indexes can make migrations complex, and it is better to deal with "
"them explicitly. Indexes may be needed for those fields that are used in "
"recurrent queries."
msgstr ""
"Attualmente l'API DAL non fornisce un comando per creare indici sulle tabelle, "
"ma questo può essere fatto usando il comando ''executesql''. Ciò è dovuto al "
"fatto che l'esistenza di indici può rendere complesse le migrazioni ed è meglio "
"gestirle in modo esplicito. Gli indici possono essere necessari per i campi "
"utilizzati nelle query ricorrenti."

#: ../../chapter-07.rst:1779
msgid "Here is an example of how to:"
msgstr "Di seguito è riportato un esempio di come:"

#: ../../chapter-07.rst:1787
msgid ""
"Other database dialects have very similar syntaxes but may not support the "
"optional “IF NOT EXISTS” directive."
msgstr ""
"Altri dialetti di database hanno sintassi molto simili, ma potrebbero non "
"supportare la direttiva facoltativa \"IF NOT EXISTS\"."

#: ../../chapter-07.rst:1791
msgid "Generating raw SQL"
msgstr "Generazione di SQL non elaborato"

#: ../../chapter-07.rst:1793
msgid ""
"Sometimes you need to generate the SQL but not execute it. This is easy to do "
"with py4web since every command that performs database IO has an equivalent "
"command that does not, and simply returns the SQL that would have been "
"executed. These commands have the same names and syntax as the functional ones, "
"but they start with an underscore:"
msgstr ""
"A volte è necessario generare l'SQL ma non eseguirlo. Questa operazione è "
"facile da eseguire con py4web poiché ogni comando che esegue l'I/O del database "
"ha un comando equivalente che non lo fa e restituisce semplicemente l'SQL che "
"sarebbe stato eseguito. Questi comandi hanno gli stessi nomi e la stessa "
"sintassi di quelli funzionali, ma iniziano con un carattere di sottolineatura:"

#: ../../chapter-07.rst:1799
msgid "Here is ``_insert``"
msgstr "Ecco ''_insert''"

#: ../../chapter-07.rst:1806
msgid "Here is ``_count``"
msgstr "Ecco ''_count''"

#: ../../chapter-07.rst:1813
msgid "Here is ``_select``"
msgstr "Ecco ''_select''"

#: ../../chapter-07.rst:1820
msgid "Here is ``_delete``"
msgstr "Ecco ''_delete''"

#: ../../chapter-07.rst:1827
msgid "And finally, here is ``_update``"
msgstr "E infine, ecco ''_update''"

#: ../../chapter-07.rst:1836
msgid ""
"Moreover you can always use ``db._lastsql`` to return the most recent SQL code, "
"whether it was executed manually using executesql or was SQL generated by the "
"DAL."
msgstr ""
"Inoltre è sempre possibile utilizzare ''db._lastsql'' per restituire il codice "
"SQL più recente, sia che sia stato eseguito manualmente utilizzando executesql "
"sia che sia stato generato da SQL dal DAL."

#: ../../chapter-07.rst:1842
msgid "``select`` command"
msgstr "Comando ''select''"

#: ../../chapter-07.rst:1844
msgid "Given a Set, ``s``, you can fetch the records with the command ``select``:"
msgstr ""
"Dato un Set, ''s'', è possibile recuperare i record con il comando ''select'':"

#: ../../chapter-07.rst:1851
msgid ""
"It returns an iterable object of class ``pydal.objects.Rows`` whose elements "
"are Row objects. ``pydal.objects.Row`` objects act like dictionaries, but their "
"elements can also be accessed as attributes. The former differ from the latter "
"because its values are read-only."
msgstr ""
"Restituisce un oggetto iterabile della classe ''pydal.objects.Rows'' i cui "
"elementi sono oggetti Row. Gli oggetti ''pydal.objects.Row'' agiscono come "
"dizionari, ma è possibile accedere ai loro elementi anche come attributi. Il "
"primo differisce dal secondo perché i suoi valori sono di sola lettura."

#: ../../chapter-07.rst:1857
msgid ""
"The Rows object allows looping over the result of the select and printing the "
"selected field values for each row:"
msgstr ""
"L'oggetto Righe consente di eseguire il ciclo sul risultato della selezione e "
"di stampare i valori dei campi selezionati per ogni riga:"

#: ../../chapter-07.rst:1867
msgid "You can do all the steps in one statement:"
msgstr "È possibile eseguire tutti i passaggi in un'unica istruzione:"

#: ../../chapter-07.rst:1876
msgid ""
"The select command can take arguments. All unnamed arguments are interpreted as "
"the names of the fields that you want to fetch. For example, you can be "
"explicit on fetching field “id” and field “name”:"
msgstr ""
"Il comando select può accettare argomenti. Tutti gli argomenti senza nome "
"vengono interpretati come nomi dei campi che si desidera recuperare. Ad "
"esempio, puoi essere esplicito sul recupero del campo \"id\" e del campo "
"\"name\":"

#: ../../chapter-07.rst:1889
msgid "The table attribute ALL allows you to specify all fields:"
msgstr "L'attributo table ALL consente di specificare tutti i campi:"

#: ../../chapter-07.rst:1900
msgid ""
"Notice that there is no query string passed to db. py4web understands that if "
"you want all fields of the table person without additional information then you "
"want all records of the table person."
msgstr ""
"Si noti che non è presente alcuna stringa di query passata a db. py4web capisce "
"che se si desidera che tutti i campi della persona della tabella non siano "
"informazioni aggiuntive, allora si desidera che tutti i record della persona "
"della tabella."

#: ../../chapter-07.rst:1904
msgid "An equivalent alternative syntax is the following:"
msgstr "Una sintassi alternativa equivalente è la seguente:"

#: ../../chapter-07.rst:1915
msgid ""
"and py4web understands that if you ask for all records of the table person "
"without additional information, then you want all the fields of table person."
msgstr ""
"E py4web capisce che se chiedi tutti i record della persona del tavolo senza "
"informazioni aggiuntive, allora vuoi tutti i campi della persona del tavolo."

#: ../../chapter-07.rst:1919
msgid "Given one row"
msgstr "Data una riga"

#: ../../chapter-07.rst:1925
msgid "you can extract its values using multiple equivalent expressions:"
msgstr "È possibile estrarne i valori utilizzando più espressioni equivalenti:"

#: ../../chapter-07.rst:1936
msgid ""
"The latter syntax is particularly handy when selecting an expression instead of "
"a column. We will show this later."
msgstr ""
"Quest'ultima sintassi è particolarmente utile quando si seleziona "
"un'espressione anziché una colonna. Lo mostreremo più avanti."

#: ../../chapter-07.rst:1939
msgid "You can also do"
msgstr "Puoi anche fare"

#: ../../chapter-07.rst:1945
msgid "to disable the notation"
msgstr "Per disabilitare la notazione"

#: ../../chapter-07.rst:1951
msgid "and enable, instead, the less compact notation:"
msgstr "e abilitare, invece, la notazione meno compatta:"

#: ../../chapter-07.rst:1957
msgid "Yes this is unusual and rarely needed."
msgstr "Sì, questo è insolito e raramente necessario."

#: ../../chapter-07.rst:1959
msgid "Row objects also have two important methods:"
msgstr "Gli oggetti riga hanno anche due metodi importanti:"

#: ../../chapter-07.rst:1965
msgid "and"
msgstr "e"

#: ../../chapter-07.rst:1972
msgid "Using an iterator-based select for lower memory use"
msgstr ""
"Uso di una selezione basata su iteratore per un utilizzo inferiore della memoria"

#: ../../chapter-07.rst:1974
msgid ""
"Python “iterators” are a type of “lazy-evaluation”. They ‘feed’ data one step "
"at time; traditional Python loops create the entire set of data in memory "
"before looping."
msgstr ""
"Gli \"iteratori\" di Python sono un tipo di \"valutazione pigra\". "
"\"Alimentano\" i dati un passo alla volta; I cicli Python tradizionali creano "
"l'intero set di dati in memoria prima del ciclo."

#: ../../chapter-07.rst:1978
msgid "The traditional use of select is:"
msgstr "L'uso tradizionale di select è:"

#: ../../chapter-07.rst:1985
msgid ""
"but for large numbers of rows, using an iterator-based alternative has "
"dramatically lower memory use:"
msgstr ""
"Tuttavia, per un numero elevato di righe, l'uso di un'alternativa basata su "
"iteratore riduce notevolmente l'utilizzo della memoria:"

#: ../../chapter-07.rst:1993
#, python-format
msgid ""
"Testing shows this is around 10% faster as well, even on machines with large "
"RAM."
msgstr ""
"I test mostrano che anche questo è di circa 10% faster, anche su macchine con "
"RAM di grandi dimensioni."

#: ../../chapter-07.rst:1997
msgid "Rendering rows using represent"
msgstr "Rendering delle righe con represent"

#: ../../chapter-07.rst:1999
msgid ""
"You may wish to rewrite rows returned by select to take advantage of formatting "
"information contained in the represents setting of the fields."
msgstr ""
"È possibile riscrivere le righe restituite da select per sfruttare le "
"informazioni di formattazione contenute nell'impostazione represents dei campi."

#: ../../chapter-07.rst:2008
msgid ""
"If you don’t specify an index, you get a generator to iterate over all the rows:"
msgstr ""
"Se non si specifica un indice, si ottiene un generatore per eseguire "
"l'iterazione su tutte le righe:"

#: ../../chapter-07.rst:2016
msgid "Can also be applied to slices:"
msgstr "Può essere applicato anche alle fette:"

#: ../../chapter-07.rst:2023
msgid ""
"If you only want to transform selected fields via their “represent” attribute, "
"you can list them in the “fields” argument:"
msgstr ""
"Se si desidera trasformare i campi selezionati solo tramite il loro attributo "
"\"represent\", è possibile elencarli nell'argomento \"fields\":"

#: ../../chapter-07.rst:2030
msgid ""
"Note, it returns a transformed copy of the original Row, so there’s no "
"update_record (which you wouldn't want anyway) or delete_record."
msgstr ""
"Si noti che restituisce una copia trasformata della riga originale, quindi non "
"c'è update_record (che comunque non vorresti) o delete_record."

#: ../../chapter-07.rst:2034
msgid "Shortcuts"
msgstr "Scelte rapide"

#: ../../chapter-07.rst:2036
msgid "The DAL supports various code-simplifying shortcuts. In particular:"
msgstr ""
"Il DAL supporta varie scorciatoie che semplificano il codice. Soprattutto:"

#: ../../chapter-07.rst:2042
msgid ""
"returns the record with the given ``id`` if it exists. If the ``id`` does not "
"exist, it returns ``None``. The above statement is equivalent to"
msgstr ""
"Restituisce il record con l''''ID'' dato, se esiste. Se l''id'' non esiste, "
"restituisce ''None''. L'affermazione di cui sopra equivale a"

#: ../../chapter-07.rst:2050
msgid "You can delete records by id:"
msgstr "È possibile eliminare i record in base all'ID:"

#: ../../chapter-07.rst:2056
msgid "and this is equivalent to"
msgstr "e questo equivale a"

#: ../../chapter-07.rst:2062
msgid "and deletes the record with the given ``id``, if it exists."
msgstr "e cancella il record con l''''id'' dato, se esiste."

#: ../../chapter-07.rst:2064
msgid ""
"Note: this delete shortcut syntax does not currently work if *versioning* is "
"activated"
msgstr ""
"Nota: questa sintassi di eliminazione della scorciatoia non funziona "
"attualmente se è attivato il *versioning*"

#: ../../chapter-07.rst:2067
msgid "You can insert records:"
msgstr "È possibile inserire record:"

#: ../../chapter-07.rst:2073
msgid "It is equivalent to"
msgstr "Equivale a"

#: ../../chapter-07.rst:2079
msgid ""
"and it creates a new record with field values specified by the dictionary on "
"the right hand side."
msgstr ""
"e crea un nuovo record con i valori dei campi specificati dal dizionario sul "
"lato destro."

#: ../../chapter-07.rst:2082
msgid ""
"Note: insert shortcut was previously ``db.table[0] = ...``. It has changed in "
"pyDAL 19.02 to permit normal usage of id 0."
msgstr ""
"Nota: la scorciatoia per l'inserimento era in precedenza ''db.table[0] = ...''. "
"È stato modificato in pyDAL 19.02 per consentire il normale utilizzo di id 0."

#: ../../chapter-07.rst:2088
msgid "You can update records:"
msgstr "È possibile aggiornare i record:"

#: ../../chapter-07.rst:2094 ../../chapter-07.rst:2138
msgid "which is equivalent to"
msgstr "che è equivalente a"

#: ../../chapter-07.rst:2100
msgid ""
"and it updates an existing record with field values specified by the dictionary "
"on the right hand side."
msgstr ""
"e aggiorna un record esistente con i valori dei campi specificati dal "
"dizionario sul lato destro."

#: ../../chapter-07.rst:2104
msgid "Fetching a ``Row``"
msgstr "Recuperare una ''riga''"

#: ../../chapter-07.rst:2106
msgid "Yet another convenient syntax is the following:"
msgstr "Un'altra sintassi utile è la seguente:"

#: ../../chapter-07.rst:2114
msgid ""
"Apparently similar to ``db.mytable[id]`` the above syntax is more flexible and "
"safer. First of all it checks whether ``id`` is an int (or ``str(id)`` is an "
"int) and returns ``None`` if not (it never raises an exception). It also allows "
"to specify multiple conditions that the record must meet. If they are not met, "
"it also returns ``None``."
msgstr ""
"Apparentemente simile a ''db.mytable[id]'', la sintassi di cui sopra è più "
"flessibile e sicura. Prima di tutto controlla se ''id'' è un int (o ''str(id)'' "
"è un int) e restituisce ''None'' in caso contrario (non solleva mai "
"un'eccezione). Consente inoltre di specificare più condizioni che il record "
"deve soddisfare. Se non vengono soddisfatti, restituisce anche ''Nessuno''."

#: ../../chapter-07.rst:2121
msgid "Recursive ``select``\\ s"
msgstr "Ricorsivo ''select''\\ s"

#: ../../chapter-07.rst:2123
msgid ""
"Consider the previous table person and a new table “thing” referencing a "
"“person”:"
msgstr ""
"Si consideri la persona della tabella precedente e una nuova \"cosa\" della "
"tabella che fa riferimento a una \"persona\":"

#: ../../chapter-07.rst:2132
msgid "and a simple select from this table:"
msgstr "e una semplice selezione da questa tabella:"

#: ../../chapter-07.rst:2144
msgid ""
"where ``_id`` is a reference to the primary key of the table. Normally ``db."
"thing._id`` is the same as ``db.thing.id`` and we will assume that in most of "
"this book."
msgstr ""
"dove ''_id'' è un riferimento alla chiave primaria della tabella. Normalmente "
"''db.thing._id'' è la stessa cosa di ''db.thing.id'' e lo assumeremo nella "
"maggior parte di questo libro."

#: ../../chapter-07.rst:2148
msgid ""
"For each Row of things it is possible to fetch not just fields from the "
"selected table (thing) but also from linked tables (recursively):"
msgstr ""
"Per ogni Riga di cose è possibile prelevare non solo i campi dalla tabella "
"selezionata (cosa) ma anche dalle tabelle collegate (ricorsivamente):"

#: ../../chapter-07.rst:2156
msgid ""
"Here ``thing.owner_id.name`` requires one database select for each thing in "
"things and it is therefore inefficient. We suggest using joins whenever "
"possible instead of recursive selects, nevertheless this is convenient and "
"practical when accessing individual records."
msgstr ""
"Qui ''thing.owner_id.name'' richiede una selezione del database per ogni cosa "
"nelle cose ed è quindi inefficiente. Si consiglia di utilizzare i join quando "
"possibile invece delle selezioni ricorsive, tuttavia questo è comodo e pratico "
"quando si accede ai singoli record."

#: ../../chapter-07.rst:2161
msgid ""
"You can also do it backwards, by selecting the things referenced by a person:"
msgstr ""
"Puoi anche farlo a ritroso, selezionando le cose a cui fa riferimento una "
"persona:"

#: ../../chapter-07.rst:2170
msgid "In this last expression ``person.thing`` is a shortcut for"
msgstr "In quest'ultima espressione ''persona.cosa'' è una scorciatoia per"

#: ../../chapter-07.rst:2176
msgid ""
"i.e. the Set of ``thing``\\ s referenced by the current ``person``. This syntax "
"breaks down if the referencing table has multiple references to the referenced "
"table. In this case one needs to be more explicit and use a full Query."
msgstr ""
"cioè l'insieme di ''cose'' a cui fa riferimento la ''persona'' corrente. Questa "
"sintassi viene interrotta se la tabella di riferimento contiene più riferimenti "
"alla tabella a cui si fa riferimento. In questo caso è necessario essere più "
"espliciti e utilizzare una query completa."

#: ../../chapter-07.rst:2184
msgid ""
"``orderby``, ``groupby``, ``limitby``, ``distinct``, ``having``, "
"``orderby_on_limitby``, ``join``, ``left``, ``cache``"
msgstr ""
"''orderby'', ''groupby'', ''limitby'', ''distinct'', ''having'', "
"''orderby_on_limitby'', ''join'', ''left'', ''cache''"

#: ../../chapter-07.rst:2186
msgid "The ``select`` command takes a number of optional arguments."
msgstr "Il comando ''select'' accetta un certo numero di argomenti opzionali."

#: ../../chapter-07.rst:2189
msgid "orderby"
msgstr "ordina per"

#: ../../chapter-07.rst:2191
msgid "You can fetch the records sorted by name:"
msgstr "È possibile recuperare i record ordinati per nome:"

#: ../../chapter-07.rst:2202
msgid ""
"You can fetch the records sorted by name in reverse order (notice the tilde):"
msgstr ""
"È possibile recuperare i record ordinati per nome in ordine inverso (notare la "
"tilde):"

#: ../../chapter-07.rst:2214
msgid "You can have the fetched records appear in random order:"
msgstr ""
"È possibile fare in modo che i record recuperati vengano visualizzati in ordine "
"casuale:"

#: ../../chapter-07.rst:2227
msgid ""
"The use of ``orderby='<random>'`` is not supported on Google NoSQL. However, to "
"overcome this limit, sorting can be accomplished on selected rows:"
msgstr ""
"L'uso di ''orderby='<random>''' non è supportato su Google NoSQL. Tuttavia, per "
"superare questo limite, l'ordinamento può essere eseguito su righe selezionate:"
"</random>"

#: ../../chapter-07.rst:2236
msgid ""
"You can sort the records according to multiple fields by concatenating them "
"with a “\\|”:"
msgstr ""
"È possibile ordinare i record in base a più campi concatenandoli con un \"\\|\":"

#: ../../chapter-07.rst:2249
msgid "groupby, having"
msgstr "groupby, avendo"

#: ../../chapter-07.rst:2251
msgid ""
"Using ``groupby`` together with ``orderby``, you can group records with the "
"same value for the specified field (this is back-end specific, and is not on "
"the Google NoSQL):"
msgstr ""
"Usando ''groupby'' insieme a ''orderby'', puoi raggruppare i record con lo "
"stesso valore per il campo specificato (questo è specifico del back-end e non è "
"su Google NoSQL):"

#: ../../chapter-07.rst:2266
msgid ""
"You can use ``having`` in conjunction with ``groupby`` to group conditionally "
"(only those ``having`` the condition are grouped)."
msgstr ""
"Si può usare ''avere'' in congiunzione con ''groupby'' per raggruppare in modo "
"condizionale (solo quelli che ''hanno'' la condizione sono raggruppati)."

#: ../../chapter-07.rst:2273
msgid ""
"Notice that query1 filters records to be displayed, query2 filters records to "
"be grouped."
msgstr ""
"Si noti che query1 filtra i record da visualizzare, query2 filtra i record da "
"raggruppare."

#: ../../chapter-07.rst:2277
msgid "distinct"
msgstr "distinto"

#: ../../chapter-07.rst:2279
msgid ""
"With the argument ``distinct=True``, you can specify that you only want to "
"select distinct records. This has the same effect as grouping using all "
"specified fields except that it does not require sorting. When using distinct "
"it is important not to select ALL fields, and in particular not to select the "
"“id” field, else all records will always be distinct."
msgstr ""
"Con l'argomento ''distinct=True'', è possibile specificare che si desidera "
"selezionare solo record distinti. Questo ha lo stesso effetto del "
"raggruppamento utilizzando tutti i campi specificati, tranne per il fatto che "
"non richiede l'ordinamento. Quando si utilizza distinct è importante non "
"selezionare TUTTI i campi, e in particolare non selezionare il campo \"id\", "
"altrimenti tutti i record saranno sempre distinti."

#: ../../chapter-07.rst:2285 ../../chapter-07.rst:3347
msgid "Here is an example:"
msgstr "Ecco un esempio:"

#: ../../chapter-07.rst:2296
msgid "Notice that ``distinct`` can also be an expression, for example:"
msgstr "Si noti che ''distinct'' può anche essere un'espressione, per esempio:"

#: ../../chapter-07.rst:2308
msgid "limitby"
msgstr "limitdi"

#: ../../chapter-07.rst:2310
msgid ""
"With ``limitby=(min, max)``, you can select a subset of the records from "
"offset=min to but not including offset=max. In the next example we select the "
"first two records starting at zero:"
msgstr ""
"Con ''limitby=(min, max)'', è possibile selezionare un sottoinsieme dei record "
"da offset=min a ma non include offset=max. Nell'esempio seguente selezioniamo i "
"primi due record a partire da zero:"

#: ../../chapter-07.rst:2323
msgid "orderby_on_limitby"
msgstr "orderby_on_limitby"

#: ../../chapter-07.rst:2325
msgid ""
"Note that the DAL defaults to implicitly adding an orderby when using a "
"limitby. This ensures the same query returns the same results each time, "
"important for pagination. But it can cause performance problems. use "
"``orderby_on_limitby = False`` to change this (this defaults to True)."
msgstr ""
"Si noti che per impostazione predefinita il DAL aggiunge in modo implicito un "
"orderby quando si utilizza un limitby. In questo modo si garantisce che la "
"stessa query restituisca ogni volta gli stessi risultati, importante per "
"l'impaginazione. Ma può causare problemi di prestazioni. usa "
"''orderby_on_limitby = False'' per cambiarlo (il valore predefinito è True)."

#: ../../chapter-07.rst:2331
msgid "join, left"
msgstr "Unisci, a sinistra"

#: ../../chapter-07.rst:2333
msgid ""
"These are involved in managing `One to many relation`_. They are described in "
"`Inner join`_ and `Left outer join`_ sections respectively."
msgstr ""
"Questi sono coinvolti nella gestione della \"relazione uno-a-molti\". Sono "
"descritti rispettivamente nelle sezioni 'Inner join'_ e 'Left outer join'_."

#: ../../chapter-07.rst:2337
msgid "cache, cacheable"
msgstr "cache, memorizzabile nella cache"

#: ../../chapter-07.rst:2339
msgid "An example use which gives much faster selects is:"
msgstr "Un esempio di utilizzo che dà selezioni molto più veloci è:"

#: ../../chapter-07.rst:2345
msgid "Look at `Caching selects`_, to understand what the trade-offs are."
msgstr ""
"Dai un'occhiata a 'Caching selects'_, per capire quali sono i compromessi."

#: ../../chapter-07.rst:2348
msgid "Logical operators"
msgstr "Operatori logici"

#: ../../chapter-07.rst:2350
msgid "Queries can be combined using the binary AND operator “``&``”:"
msgstr ""
"Le query possono essere combinate utilizzando l'operatore binario AND \"''&''\":"

#: ../../chapter-07.rst:2359
msgid "and the binary OR operator “``|``”:"
msgstr "e l'operatore binario OR \"''|''\":"

#: ../../chapter-07.rst:2367
msgid "You can negate a sub-query inverting its operator:"
msgstr "È possibile negare una sottoquery invertendone l'operatore:"

#: ../../chapter-07.rst:2376
msgid "or by explicit negation with the “``~``” unary operator:"
msgstr "o per negazione esplicita con l'operatore unario \"''~''\"\":"

#: ../../chapter-07.rst:2387
msgid ""
"Due to Python restrictions in overloading “``and``” and “``or``” operators, "
"these cannot be used in forming queries. The binary operators “``&``” and “``|"
"``” must be used instead. Note that these operators (unlike “``and``” and "
"“``or``”) have higher precedence than comparison operators, so the “extra” "
"parentheses in the above examples are mandatory. Similarly, the unary operator "
"“``~``” has higher precedence than comparison operators, so ``~``-negated "
"comparisons must also be parenthesized."
msgstr ""
"A causa delle restrizioni di Python nell'overload degli operatori \"''and''\" e "
"\"''or''\", questi non possono essere utilizzati nella formazione di query. Al "
"loro posto devono essere utilizzati gli operatori binari \"''&''\" e \"''|''\". "
"Si noti che questi operatori (a differenza di \"''and''\" e \"''or''\") hanno "
"una precedenza maggiore rispetto agli operatori di confronto, quindi le "
"parentesi \"extra\" negli esempi precedenti sono obbligatorie. Allo stesso "
"modo, l'operatore unario \"''~''\" ha una precedenza maggiore rispetto agli "
"operatori di confronto, quindi anche i confronti negati da ''~'' devono essere "
"messi tra parentesi."

#: ../../chapter-07.rst:2396
msgid "It is also possible to build queries using in-place logical operators:"
msgstr "È anche possibile creare query utilizzando operatori logici sul posto:"

#: ../../chapter-07.rst:2405
msgid "``count``, ``isempty``, ``delete``, ``update``"
msgstr "''Conta'', ''Èvuoto'', ''Elimina'', ''Aggiorna''"

#: ../../chapter-07.rst:2407
msgid "You can count records in a set:"
msgstr "È possibile contare i record in un set:"

#: ../../chapter-07.rst:2414
msgid ""
"Notice that ``count`` takes an optional ``distinct`` argument which defaults to "
"False, and it works very much like the same argument for ``select``. ``count`` "
"has also a ``cache`` argument that works very much like the equivalent argument "
"of the ``select`` method."
msgstr ""
"Si noti che ''count'' accetta un argomento opzionale ''distinct'' che di "
"default è False, e funziona in modo molto simile allo stesso argomento per "
"''select''. ''count'' ha anche un argomento ''cache'' che funziona in modo "
"molto simile all'argomento equivalente del metodo ''select''."

#: ../../chapter-07.rst:2419
msgid ""
"Sometimes you may need to check if a table is empty. A more efficient way than "
"counting is using the ``isempty`` method:"
msgstr ""
"A volte potrebbe essere necessario controllare se una tabella è vuota. Un modo "
"più efficiente del conteggio è usare il metodo ''isempty'':"

#: ../../chapter-07.rst:2427
msgid "You can delete records in a set:"
msgstr "È possibile eliminare i record in un set:"

#: ../../chapter-07.rst:2434
msgid "The ``delete`` method returns the number of records that were deleted."
msgstr ""
"Il metodo ''delete'' restituisce il numero di record che sono stati eliminati."

#: ../../chapter-07.rst:2436
msgid ""
"And you can update all records in a set by passing named arguments "
"corresponding to the fields that need to be updated:"
msgstr ""
"Ed è possibile aggiornare tutti i record in un set passando argomenti "
"denominati corrispondenti ai campi che devono essere aggiornati:"

#: ../../chapter-07.rst:2444
msgid "The ``update`` method returns the number of records that were updated."
msgstr ""
"Il metodo ''update'' restituisce il numero di record che sono stati aggiornati."

#: ../../chapter-07.rst:2447
msgid "Expressions"
msgstr "Espressioni"

#: ../../chapter-07.rst:2449
msgid ""
"The value assigned an update statement can be an expression. For example "
"consider this model"
msgstr ""
"Il valore assegnato a un'istruzione update può essere un'espressione. Si "
"consideri, ad esempio, questo modello"

#: ../../chapter-07.rst:2460
msgid "The values used in queries can also be expressions"
msgstr "I valori utilizzati nelle query possono anche essere espressioni"

#: ../../chapter-07.rst:2472
msgid "``case``"
msgstr "''Caso''"

#: ../../chapter-07.rst:2474
msgid "An expression can contain a case clause for example:"
msgstr "Un'espressione può contenere una clausola case, ad esempio:"

#: ../../chapter-07.rst:2488
msgid "``update_record``"
msgstr "''update_record''"

#: ../../chapter-07.rst:2490
msgid ""
"py4web also allows updating a single record that is already in memory using "
"``update_record``"
msgstr ""
"py4web permette anche di aggiornare un singolo record già in memoria usando "
"''update_record''"

#: ../../chapter-07.rst:2499
msgid "``update_record`` should not be confused with"
msgstr "''update_record'' non deve essere confuso con"

#: ../../chapter-07.rst:2505
msgid ""
"because for a single row, the method ``update`` updates the row object but not "
"the database record, as in the case of ``update_record``."
msgstr ""
"Perché per una singola riga, il metodo ''update'' aggiorna l'oggetto riga ma "
"non il record del database, come nel caso di ''update_record''."

#: ../../chapter-07.rst:2508
msgid ""
"It is also possible to change the attributes of a row (one at a time) and then "
"call ``update_record()`` without arguments to save the changes:"
msgstr ""
"E' anche possibile cambiare gli attributi di una riga (uno alla volta) e poi "
"chiamare ''update_record()'' senza argomenti per salvare le modifiche:"

#: ../../chapter-07.rst:2520
msgid ""
"Note, you should avoid using ``row.update_record()`` with no arguments when the "
"``row`` object contains fields that have an ``update`` attribute (e.g., "
"``Field('modified_on', update=datetime.datetime.utcnow)``). Calling ``row."
"update_record()`` will retain *all* of the existing values in the ``row`` "
"object, so any fields with ``update`` attributes will have no effect in this "
"case. Be particularly mindful of this with tables that include ``auth."
"signature``."
msgstr ""
"Nota, si dovrebbe evitare di usare ''row.update_record()'' senza argomenti "
"quando l'oggetto ''row'' contiene campi che hanno un attributo ''update'' (ad "
"esempio, ''Field('modified_on', update=datetime.datetime.utcnow)''). Chiamare "
"''row.update_record()'' manterrà *tutti* i valori esistenti nell'oggetto "
"''row'', quindi tutti i campi con attributi ''update'' non avranno alcun "
"effetto in questo caso. Prestare particolare attenzione a questo aspetto con le "
"tabelle che includono ''auth.signature''."

#: ../../chapter-07.rst:2529
msgid ""
"The ``update_record`` method is available only if the table’s ``id`` field is "
"included in the select, and ``cacheable`` is not set to ``True``."
msgstr ""
"Il metodo ''update_record'' è disponibile solo se il campo ''id'' della tabella "
"è incluso nella selezione, e ''cacheable'' non è impostato a ''True''."

#: ../../chapter-07.rst:2534
msgid "Inserting and updating from a dictionary"
msgstr "Inserimento e aggiornamento da un dizionario"

#: ../../chapter-07.rst:2536
msgid ""
"A common issue consists of needing to insert or update records in a table where "
"the name of the table, the field to be updated, and the value for the field are "
"all stored in variables. For example: ``tablename``, ``fieldname``, and "
"``value``."
msgstr ""
"Un problema comune consiste nella necessità di inserire o aggiornare i record "
"in una tabella in cui il nome della tabella, il campo da aggiornare e il valore "
"del campo sono tutti memorizzati in variabili. Ad esempio: ''tablename'', "
"''fieldname'' e ''value''."

#: ../../chapter-07.rst:2541
msgid "The insert can be done using the following syntax:"
msgstr "L'inserimento può essere eseguito utilizzando la seguente sintassi:"

#: ../../chapter-07.rst:2547
msgid "The update of record with given id can be done with:"
msgstr ""
"L'aggiornamento del record con l'id specificato può essere effettuato con:"

#: ../../chapter-07.rst:2553
msgid ""
"Notice we used ``table._id`` instead of ``table.id``. In this way the query "
"works even for tables with a primary key field with type other than “id”."
msgstr ""
"Notate che abbiamo usato ''table._id'' invece di ''table.id''. In questo modo "
"la query funziona anche per le tabelle con un campo di chiave primaria con tipo "
"diverso da \"id\"."

#: ../../chapter-07.rst:2558
msgid "``first`` and ``last``"
msgstr "''primo'' e ''ultimo''"

#: ../../chapter-07.rst:2560
msgid "Given a Rows object containing records:"
msgstr "Dato un oggetto Rows contenente record:"

#: ../../chapter-07.rst:2568
msgid "are equivalent to"
msgstr "sono equivalenti a"

#: ../../chapter-07.rst:2575
msgid ""
"Notice, ``first()`` and ``last()`` allow you to obtain obviously the first and "
"last record present in your query, but this won’t mean that these records are "
"going to be the first or last inserted records. In case you want the first or "
"last record inputted in a given table don’t forget to use ``orderby=db."
"table_name.id``. If you forget you will only get the first and last record "
"returned by your query which are often in a random order determined by the "
"backend query optimiser."
msgstr ""
"Si noti che ''first()'' e ''last()'' consentono di ottenere ovviamente il primo "
"e l'ultimo record presente nella query, ma questo non significa che questi "
"record saranno il primo o l'ultimo record inserito. Nel caso in cui si desideri "
"inserire il primo o l'ultimo record in una determinata tabella, non dimenticare "
"di usare ''orderby=db.table_name.id''. Se ci si dimentica, si otterranno solo "
"il primo e l'ultimo record restituiti dalla query, che sono spesso in un ordine "
"casuale determinato dall'ottimizzatore di query back-end."

#: ../../chapter-07.rst:2584
msgid "``as_dict`` and ``as_list``"
msgstr "''as_dict'' e ''as_list''"

#: ../../chapter-07.rst:2586
msgid ""
"A Row object can be serialized into a regular dictionary using the "
"``as_dict()`` method and a Rows object can be serialized into a list of "
"dictionaries using the ``as_list()`` method. Here are some examples:"
msgstr ""
"Un oggetto Row può essere serializzato in un normale dizionario usando il "
"metodo ''as_dict()'' e un oggetto Rows può essere serializzato in un elenco di "
"dizionari usando il metodo ''as_list()''. Ecco alcuni esempi:"

#: ../../chapter-07.rst:2596
msgid ""
"These methods are convenient for passing Rows to generic views and or to store "
"Rows in sessions (Rows objects themselves cannot be serialized because they "
"contain a reference to an open DB connection):"
msgstr ""
"Questi metodi sono utili per passare le righe a viste generiche e/o per "
"archiviare le righe nelle sessioni (gli oggetti Rows stessi non possono essere "
"serializzati perché contengono un riferimento a una connessione DB aperta):"

#: ../../chapter-07.rst:2607
msgid "Combining rows"
msgstr "Combinazione di righe"

#: ../../chapter-07.rst:2609
msgid "Rows objects can be combined at the Python level. Here we assume:"
msgstr ""
"Gli oggetti Rows possono essere combinati a livello di Python. Qui assumiamo:"

#: ../../chapter-07.rst:2623
msgid "You can do union of the records in two sets of rows:"
msgstr "È possibile eseguire l'unione dei record in due serie di righe:"

#: ../../chapter-07.rst:2635
msgid "You can do union of the records removing duplicates:"
msgstr "È possibile eseguire l'unione dei record rimuovendo i duplicati:"

#: ../../chapter-07.rst:2646
msgid "You can do intersection of the records in two sets of rows:"
msgstr "È possibile eseguire l'intersezione dei record in due serie di righe:"

#: ../../chapter-07.rst:2656
msgid "``find``, ``exclude``, ``sort``"
msgstr "''trovare'', ''escludere'', ''ordinare''"

#: ../../chapter-07.rst:2658
msgid ""
"Some times you need to perform two selects and one contains a subset of a "
"previous select. In this case it is pointless to access the database again. The "
"``find``, ``exclude`` and ``sort`` objects allow you to manipulate a Rows "
"object and generate another one without accessing the database. More "
"specifically: - ``find`` returns a new set of Rows filtered by a condition and "
"leaves the original unchanged. - ``exclude`` returns a new set of Rows filtered "
"by a condition and removes them from the original Rows. - ``sort`` returns a "
"new set of Rows sorted by a condition and leaves the original unchanged."
msgstr ""
"A volte è necessario eseguire due selezioni e una contiene un sottoinsieme di "
"una selezione precedente. In questo caso è inutile accedere nuovamente al "
"database. Gli oggetti ''find'', ''exclude'' e ''sort'' consentono di manipolare "
"un oggetto Rows e generarne un altro senza accedere al database. Più "
"specificamente: - ''find'' restituisce un nuovo set di righe filtrate da una "
"condizione e lascia invariato l'originale. - ''exclude'' restituisce un nuovo "
"set di righe filtrate da una condizione e le rimuove dalle righe originali. - "
"''sort'' restituisce un nuovo set di righe ordinate in base a una condizione e "
"lascia invariato l'originale."

#: ../../chapter-07.rst:2668
msgid ""
"All these methods take a single argument, a function that acts on each "
"individual row."
msgstr ""
"Tutti questi metodi accettano un singolo argomento, una funzione che agisce su "
"ogni singola riga."

#: ../../chapter-07.rst:2671
msgid "Here is an example of usage:"
msgstr "Di seguito è riportato un esempio di utilizzo:"

#: ../../chapter-07.rst:2702
msgid "They can be combined:"
msgstr "Possono essere combinati:"

#: ../../chapter-07.rst:2714
msgid "Sort takes an optional argument ``reverse=True`` with the obvious meaning."
msgstr ""
"Sort accetta un argomento opzionale ''reverse=True'' con l'ovvio significato."

#: ../../chapter-07.rst:2717
msgid ""
"The ``find`` method has an optional ``limitby`` argument with the same syntax "
"and functionality as the Set ``select`` method."
msgstr ""
"Il metodo ''find'' ha un argomento opzionale ''limitby'' con la stessa sintassi "
"e funzionalità del metodo set ''select''."

#: ../../chapter-07.rst:2721
msgid "Caching selects"
msgstr "Selezioni di memorizzazione nella cache"

#: ../../chapter-07.rst:2723
msgid ""
"The select method also takes a ``cache`` argument, which defaults to None. For "
"caching purposes, it should be set to a tuple where the first element is the "
"cache model (``cache.ram``, ``cache.disk``, etc.), and the second element is "
"the expiration time in seconds."
msgstr ""
"Il metodo select accetta anche un argomento ''cache'', che per impostazione "
"predefinita è None. Ai fini della memorizzazione nella cache, dovrebbe essere "
"impostato su una tupla in cui il primo elemento è il modello di cache (''cache."
"ram'', ''cache.disk'', ecc.), e il secondo elemento è il tempo di scadenza in "
"secondi."

#: ../../chapter-07.rst:2728
msgid ""
"In the following example, you see a controller that caches a select on the "
"previously defined db.log table. The actual select fetches data from the back-"
"end database no more frequently than once every 60 seconds and stores the "
"result in memory. If the next call to this controller occurs in less than 60 "
"seconds since the last database IO, it simply fetches the previous data from "
"memory."
msgstr ""
"Nell'esempio seguente viene visualizzato un controller che memorizza nella "
"cache una selezione nella tabella db.log definita in precedenza. La selezione "
"effettiva recupera i dati dal database back-end con una frequenza non superiore "
"a una volta ogni 60 secondi e archivia il risultato in memoria. Se la chiamata "
"successiva a questo controller si verifica in meno di 60 secondi dall'ultimo I/"
"O del database, recupera semplicemente i dati precedenti dalla memoria."

#: ../../chapter-07.rst:2741
msgid ""
"The ``select`` method has an optional ``cacheable`` argument, normally set to "
"False. When ``cacheable=True`` the resulting ``Rows`` is serializable but The "
"``Row``\\ s lack ``update_record`` and ``delete_record`` methods."
msgstr ""
"Il metodo ''select'' ha un argomento opzionale ''cacheable'', normalmente "
"impostato a False. Quando ''cacheable=True'' le ''Righe'' risultanti sono "
"serializzabili, ma le ''Riga''\\ mancano dei metodi ''update_record'' e "
"''delete_record''."

#: ../../chapter-07.rst:2746
msgid ""
"If you do not need these methods you can speed up selects a lot by setting the "
"``cacheable`` attribute:"
msgstr ""
"Se non hai bisogno di questi metodi puoi velocizzare molto le selezioni "
"impostando l'attributo ''cacheable'':"

#: ../../chapter-07.rst:2753
msgid ""
"When the ``cache`` argument is set but ``cacheable=False`` (default) only the "
"database results are cached, not the actual Rows object. When the ``cache`` "
"argument is used in conjunction with ``cacheable=True`` the entire Rows object "
"is cached and this results in much faster caching:"
msgstr ""
"Quando l'argomento ''cache'' è impostato ma ''cacheable=False'' (default) "
"vengono memorizzati nella cache solo i risultati del database, non l'oggetto "
"Rows effettivo. Quando l'argomento ''cache'' viene usato in combinazione con "
"''cacheable=True'' l'intero oggetto Rows viene memorizzato nella cache e questo "
"si traduce in una memorizzazione nella cache molto più veloce:"

#: ../../chapter-07.rst:2765
msgid "Computed and Virtual fields"
msgstr "Campi calcolati e virtuali"

#: ../../chapter-07.rst:2768
msgid "Computed fields"
msgstr "Campi calcolati"

#: ../../chapter-07.rst:2770
msgid ""
"DAL fields may have a ``compute`` attribute. This must be a function (or "
"lambda) that takes a Row object and returns a value for the field. When a new "
"record is modified, including both insertions and updates, if a value for the "
"field is not provided, py4web tries to compute from the other field values "
"using the ``compute`` function. Here is an example:"
msgstr ""
"I campi DAL possono avere un attributo ''compute''. Deve trattarsi di una "
"funzione (o lambda) che accetta un oggetto Row e restituisce un valore per il "
"campo. Quando un nuovo record viene modificato, inclusi sia gli inserimenti che "
"gli aggiornamenti, se non viene fornito un valore per il campo, py4web tenta di "
"calcolare dai valori degli altri campi usando la funzione ''compute''. Ecco un "
"esempio:"

#: ../../chapter-07.rst:2788
msgid ""
"Notice that the computed value is stored in the db and it is not computed on "
"retrieval, as in the case of virtual fields, described next. Two typical "
"applications of computed fields are:"
msgstr ""
"Si noti che il valore calcolato è memorizzato nel db e non viene calcolato al "
"momento del recupero, come nel caso dei campi virtuali, descritto di seguito. "
"Due applicazioni tipiche dei campi calcolati sono:"

#: ../../chapter-07.rst:2792
msgid ""
"in wiki applications, to store the processed input wiki text as HTML, to avoid "
"re-processing on every request"
msgstr ""
"nelle applicazioni wiki, per memorizzare il testo wiki di input elaborato come "
"HTML, per evitare la rielaborazione ad ogni richiesta"

#: ../../chapter-07.rst:2794
msgid ""
"for searching, to compute normalized values for a field, to be used for "
"searching."
msgstr ""
"per la ricerca, per calcolare i valori normalizzati per un campo, da utilizzare "
"per la ricerca."

#: ../../chapter-07.rst:2796
msgid ""
"Computed fields are evaluated in the order in which they are defined in the "
"table definition. A computed field can refer to previously defined computed "
"fields."
msgstr ""
"I campi calcolati vengono valutati nell'ordine in cui sono definiti nella "
"definizione della tabella. Un campo calcolato può fare riferimento a campi "
"calcolati definiti in precedenza."

#: ../../chapter-07.rst:2801
msgid "Virtual fields"
msgstr "Campi virtuali"

#: ../../chapter-07.rst:2803
msgid ""
"Virtual fields are also computed fields (as in the previous subsection) but "
"they differ from those because they are *virtual* in the sense that they are "
"not stored in the db and they are computed each time records are extracted from "
"the database. They can be used to simplify the user’s code without using "
"additional storage but they cannot be used for searching."
msgstr ""
"I campi virtuali sono anch'essi campi calcolati (come nella sottosezione "
"precedente) ma si differenziano da questi perché sono *virtuali* nel senso che "
"non sono memorizzati nel db e vengono calcolati ogni volta che i record vengono "
"estratti dal database. Possono essere utilizzati per semplificare il codice "
"dell'utente senza utilizzare spazio di archiviazione aggiuntivo, ma non possono "
"essere utilizzati per la ricerca."

#: ../../chapter-07.rst:2811
msgid "New style virtual fields (experimental)"
msgstr "Nuovi campi virtuali di stile (sperimentali)"

#: ../../chapter-07.rst:2813
msgid ""
"py4web provides a new and easier way to define virtual fields and lazy virtual "
"fields. This section is marked experimental because the APIs may still change a "
"little from what is described here."
msgstr ""
"py4web fornisce un modo nuovo e più semplice per definire i campi virtuali e i "
"campi virtuali pigri. Questa sezione è contrassegnata come sperimentale perché "
"le API potrebbero ancora cambiare leggermente rispetto a quanto descritto qui."

#: ../../chapter-07.rst:2817
msgid ""
"Here we will consider the same example as in the previous subsection. In "
"particular we consider the following model:"
msgstr ""
"Qui prenderemo in considerazione lo stesso esempio della sottosezione "
"precedente. In particolare consideriamo il seguente modello:"

#: ../../chapter-07.rst:2826 ../../chapter-07.rst:2902
msgid "One can define a ``total_price`` virtual field as"
msgstr "Si può definire un campo virtuale ''total_price'' come"

#: ../../chapter-07.rst:2832
msgid ""
"i.e. by simply defining a new field ``total_price`` to be a ``Field.Virtual``. "
"The only argument of the constructor is a function that takes a row and returns "
"the computed values."
msgstr ""
"cioè semplicemente definendo un nuovo campo ''total_price'' come un ''Field."
"Virtual''. L'unico argomento del costruttore è una funzione che accetta una "
"riga e restituisce i valori calcolati."

#: ../../chapter-07.rst:2836
msgid ""
"A virtual field defined as the one above is automatically computed for all "
"records when the records are selected:"
msgstr ""
"Un campo virtuale definito come quello precedente viene calcolato "
"automaticamente per tutti i record quando i record sono selezionati:"

#: ../../chapter-07.rst:2844
msgid ""
"It is also possible to define method fields which are calculated on-demand, "
"when called. For example:"
msgstr ""
"È anche possibile definire i campi del metodo che vengono calcolati su "
"richiesta, quando vengono chiamati. Per esempio:"

#: ../../chapter-07.rst:2853
msgid ""
"In this case ``row.discounted_total`` is not a value but a function. The "
"function takes the same arguments as the function passed to the ``Method`` "
"constructor except for ``row`` which is implicit (think of it as ``self`` for "
"objects)."
msgstr ""
"In questo caso ''row.discounted_total'' non è un valore ma una funzione. La "
"funzione accetta gli stessi argomenti della funzione passata al costruttore "
"''Method'' tranne che per ''row'' che è implicito (pensatelo come ''self'' per "
"gli oggetti)."

#: ../../chapter-07.rst:2858
msgid ""
"The lazy field in the example above allows one to compute the total price for "
"each ``item``:"
msgstr ""
"Il campo lazy nell'esempio precedente permette di calcolare il prezzo totale "
"per ogni ''articolo'':"

#: ../../chapter-07.rst:2865
msgid "And it also allows to pass an optional ``discount`` percentage (say 15%):"
msgstr ""
"E permette anche di far passare una percentuale di ''sconto'' opzionale "
"(diciamo il 15%):"

#: ../../chapter-07.rst:2872
msgid ""
"Virtual and Method fields can also be defined in place when a table is defined:"
msgstr ""
"I campi Virtuale e Metodo possono anche essere definiti sul posto quando viene "
"definita una tabella:"

#: ../../chapter-07.rst:2885
msgid ""
"Mind that virtual fields do not have the same attributes as regular fields "
"(length, default, required, etc). They do not appear in the list of ``db.table."
"fields``."
msgstr ""
"Tieni presente che i campi virtuali non hanno gli stessi attributi dei campi "
"normali (lunghezza, predefinito, obbligatorio, ecc.). Non appaiono nell'elenco "
"di ''db.table.fields''."

#: ../../chapter-07.rst:2890
msgid "Old style virtual fields"
msgstr "Campi virtuali vecchio stile"

#: ../../chapter-07.rst:2892
msgid ""
"In order to define one or more virtual fields, you can also define a container "
"class, instantiate it and link it to a table or to a select. For example, "
"consider the following table:"
msgstr ""
"Per definire uno o più campi virtuali, è anche possibile definire una classe "
"contenitore, crearne un'istanza e collegarla a una tabella o a una selezione. "
"Si consideri, ad esempio, la tabella seguente:"

#: ../../chapter-07.rst:2912
msgid ""
"Notice that each method of the class that takes a single argument (self) is a "
"new virtual field. ``self`` refers to each one row of the select. Field values "
"are referred by full path as in ``self.item.unit_price``. The table is linked "
"to the virtual fields by appending an instance of the class to the table’s "
"``virtualfields`` attribute."
msgstr ""
"Si noti che ogni metodo della classe che accetta un singolo argomento (self) è "
"un nuovo campo virtuale. ''self'' si riferisce a ciascuna riga della selezione. "
"I valori dei campi sono indicati dal percorso completo come in ''self.item."
"unit_price''. La tabella è collegata ai campi virtuali aggiungendo un'istanza "
"della classe all'attributo ''virtualfields'' della tabella."

#: ../../chapter-07.rst:2918
msgid "Virtual fields can also access recursive fields as in"
msgstr "I campi virtuali possono anche accedere a campi ricorsivi come in"

#: ../../chapter-07.rst:2935
msgid ""
"Notice the recursive field access ``self.order_item.item.unit_price`` where "
"``self`` is the looping record."
msgstr ""
"Si noti l'accesso al campo ricorsivo ''self.order_item.item.unit_price'' dove "
"''self'' è il record di looping."

#: ../../chapter-07.rst:2938
msgid "They can also act on the result of a JOIN"
msgstr "Possono anche agire sul risultato di un JOIN"

#: ../../chapter-07.rst:2953
msgid ""
"Notice how in this case the syntax is different. The virtual field accesses "
"both ``self.item.unit_price`` and ``self.order_item.quantity`` which belong to "
"the join select. The virtual field is attached to the rows of the table using "
"the ``setvirtualfields`` method of the rows object. This method takes an "
"arbitrary number of named arguments and can be used to set multiple virtual "
"fields, defined in multiple classes, and attach them to multiple tables:"
msgstr ""
"Si noti come in questo caso la sintassi sia diversa. Il campo virtuale accede "
"sia a ''self.item.unit_price'' che a ''self.order_item.quantity'' che "
"appartengono alla selezione di join. Il campo virtuale è collegato alle righe "
"della tabella usando il metodo ''setvirtualfields'' dell'oggetto rows. Questo "
"metodo accetta un numero arbitrario di argomenti denominati e può essere "
"utilizzato per impostare più campi virtuali, definiti in più classi, e "
"associarli a più tabelle:"

#: ../../chapter-07.rst:2979
msgid ""
"Virtual fields can be *lazy*; all they need to do is return a function and "
"access it by calling the function:"
msgstr ""
"I campi virtuali possono essere *pigri*; Tutto quello che devono fare è "
"restituire una funzione e accedervi chiamando la funzione:"

#: ../../chapter-07.rst:2999
msgid "or shorter using a lambda function:"
msgstr "o più breve utilizzando una funzione lambda:"

#: ../../chapter-07.rst:3009
msgid "Joins and Relations"
msgstr "Join e relazioni"

#: ../../chapter-07.rst:3012
msgid "One to many relation"
msgstr "Relazione uno-amolti"

#: ../../chapter-07.rst:3014
msgid ""
"To illustrate how to implement one to many relations with the DAL, define "
"another table “thing” that refers to the table “person” which we redefine here:"
msgstr ""
"Per illustrare come implementare le relazioni uno-a-molti con il DAL, definire "
"un'altra tabella \"cosa\" che si riferisce alla tabella \"persona\" che "
"ridefiniamo qui:"

#: ../../chapter-07.rst:3034
msgid ""
"Table “thing” has two fields, the name of the thing and the owner of the thing. "
"The “owner_id” field is a reference field, it is intended that the field "
"reference the other table by its id. A reference type can be specified in two "
"equivalent ways, either: ``Field('owner_id', 'reference person')`` or: "
"``Field('owner_id', db.person)``."
msgstr ""
"La tabella \"cosa\" ha due campi, il nome dell'oggetto e il proprietario "
"dell'oggetto. Il campo \"owner_id\" è un campo di riferimento, si intende che "
"il campo faccia riferimento all'altra tabella tramite il suo id. Un tipo di "
"riferimento può essere specificato in due modi equivalenti, ''Field('owner_id', "
"'reference person')'' o: ''Field('owner_id', db.person)''."

#: ../../chapter-07.rst:3041
msgid ""
"The latter is always converted to the former. They are equivalent except in the "
"case of lazy tables, self references or other types of cyclic references where "
"the former notation is the only allowed notation."
msgstr ""
"Quest'ultimo viene sempre convertito nel primo. Sono equivalenti, tranne nel "
"caso di tabelle lazy, autoriferimenti o altri tipi di riferimenti ciclici in "
"cui la prima notazione è l'unica notazione consentita."

#: ../../chapter-07.rst:3045
msgid "Now, insert three things, two owned by Alex and one by Bob:"
msgstr "Ora, inserisci tre cose, due di proprietà di Alex e una di Bob:"

#: ../../chapter-07.rst:3056
msgid "You can select as you did for any other table:"
msgstr "È possibile selezionare come è stato fatto per qualsiasi altra tabella:"

#: ../../chapter-07.rst:3066
msgid ""
"Because a thing has a reference to a person, a person can have many things, so "
"a record of table person now acquires a new attribute thing, which is a Set, "
"that defines the things of that person. This allows looping over all persons "
"and fetching their things easily:"
msgstr ""
"Poiché una cosa ha un riferimento a una persona, una persona può avere molte "
"cose, quindi un record di persona della tabella ora acquisisce un nuovo "
"attributo cosa, che è un Insieme, che definisce le cose di quella persona. "
"Questo permette di passare sopra tutte le persone e di recuperare facilmente le "
"loro cose:"

#: ../../chapter-07.rst:3086
msgid "Inner join"
msgstr "Join interno"

#: ../../chapter-07.rst:3088
msgid ""
"Another way to achieve a similar result is by using a join, specifically an "
"INNER JOIN. py4web performs joins automatically and transparently when the "
"query links two or more tables as in the following example:"
msgstr ""
"Un altro modo per ottenere un risultato simile consiste nell'utilizzare un "
"join, in particolare un INNER JOIN. py4web esegue i join in modo automatico e "
"trasparente quando la query collega due o più tabelle, come nell'esempio "
"seguente:"

#: ../../chapter-07.rst:3102
msgid ""
"Observe that py4web did a join, so the rows now contain two records, one from "
"each table, linked together. Because the two records may have fields with "
"conflicting names, you need to specify the table when extracting a field value "
"from a row. This means that while before you could do:"
msgstr ""
"Si noti che py4web ha eseguito un join, quindi le righe ora contengono due "
"record, uno per ogni tabella, collegati tra loro. Poiché i due record possono "
"contenere campi con nomi in conflitto, è necessario specificare la tabella "
"quando si estrae il valore di un campo da una riga. Ciò significa che mentre "
"prima potevi fare:"

#: ../../chapter-07.rst:3112
msgid ""
"and it was obvious whether this was the name of a person or a thing, in the "
"result of a join you have to be more explicit and say:"
msgstr ""
"ed era ovvio che questo fosse il nome di una persona o di una cosa, nel "
"risultato di un join devi essere più esplicito e dire:"

#: ../../chapter-07.rst:3119
msgid "or:"
msgstr "oppure:"

#: ../../chapter-07.rst:3125
msgid "There is an alternative syntax for INNER JOINS:"
msgstr "Esiste una sintassi alternativa per INNER JOINS:"

#: ../../chapter-07.rst:3137
msgid ""
"While the output is the same, the generated SQL in the two cases can be "
"different. The latter syntax removes possible ambiguities when the same table "
"is joined twice and aliased:"
msgstr ""
"Anche se l'output è lo stesso, l'SQL generato nei due casi può essere diverso. "
"Quest'ultima sintassi rimuove le possibili ambiguità quando la stessa tabella "
"viene unita due volte e sottoposta a alias:"

#: ../../chapter-07.rst:3152
msgid "The value of ``join`` can be list of ``db.table.on(...)`` to join."
msgstr ""
"Il valore di ''join'' può essere list of ''db.table.on(...) '' per unirsi."

#: ../../chapter-07.rst:3155
msgid "Left outer join"
msgstr "Giunto esterno sinistro"

#: ../../chapter-07.rst:3157
msgid ""
"Notice that Carl did not appear in the list above because he has no things. If "
"you intend to select on persons (whether they have things or not) and their "
"things (if they have any), then you need to perform a LEFT OUTER JOIN. This is "
"done using the argument “left” of the select. Here is an example:"
msgstr ""
"Si noti che Carl non è apparso nell'elenco qui sopra perché non ha cose. Se si "
"intende selezionare le persone (che abbiano o meno delle cose) e le loro cose "
"(se ne hanno), allora è necessario eseguire un LEFT OUTER JOIN. Questa "
"operazione viene eseguita utilizzando l'argomento \"left\" della selezione. "
"Ecco un esempio:"

#: ../../chapter-07.rst:3175
msgid "where:"
msgstr "dove:"

#: ../../chapter-07.rst:3181
msgid ""
"does the left join query. Here the argument of ``db.thing.on`` is the condition "
"required for the join (the same used above for the inner join). In the case of "
"a left join, it is necessary to be explicit about which fields to select."
msgstr ""
"Esegue la query di join a sinistra. Qui l'argomento di ''db.thing.on'' è la "
"condizione richiesta per il join (lo stesso usato sopra per l'inner join). Nel "
"caso di un left join, è necessario essere espliciti su quali campi selezionare."

#: ../../chapter-07.rst:3186
msgid ""
"Multiple left joins can be combined by passing a list or tuple of ``db.mytable."
"on(...)`` to the ``left`` parameter."
msgstr ""
"Più left join possono essere combinati passando una lista o una tupla di ''db."
"mytable.on(...) '' al parametro ''left''."

#: ../../chapter-07.rst:3190
msgid "Grouping and counting"
msgstr "Raggruppamento e conteggio"

#: ../../chapter-07.rst:3192
msgid ""
"When doing joins, sometimes you want to group rows according to certain "
"criteria and count them. For example, count the number of things owned by every "
"person. py4web allows this as well. First, you need a count operator. Second, "
"you want to join the person table with the thing table by owner. Third, you "
"want to select all rows (person + thing), group them by person, and count them "
"while grouping:"
msgstr ""
"Quando si eseguono join, a volte si desidera raggruppare le righe in base a "
"determinati criteri e contarle. Ad esempio, conta il numero di cose possedute "
"da ogni persona. py4web permette anche questo. Innanzitutto, è necessario un "
"operatore di conteggio. In secondo luogo, si desidera unire la tabella delle "
"persone con la tabella degli oggetti in base al proprietario. In terzo luogo, "
"si desidera selezionare tutte le righe (persona + cosa), raggrupparle per "
"persona e contarle durante il raggruppamento:"

#: ../../chapter-07.rst:3209
msgid ""
"Notice the ``count`` operator (which is built-in) is used as a field. The only "
"issue here is in how to retrieve the information. Each row clearly contains a "
"person and the count, but the count is not a field of a person nor is it a "
"table. So where does it go? It goes into the storage object representing the "
"record with a key equal to the query expression itself."
msgstr ""
"Si noti che l'operatore ''count'' (che è incorporato) è usato come campo. "
"L'unico problema qui è come recuperare le informazioni. Ogni riga contiene "
"chiaramente una persona e il conteggio, ma il conteggio non è un campo di una "
"persona né una tabella. Allora, dove va? Entra nell'oggetto di archiviazione "
"che rappresenta il record con una chiave uguale all'espressione di query stessa."

#: ../../chapter-07.rst:3216
msgid ""
"The ``count`` method of the Field object has an optional ``distinct`` argument. "
"When set to ``True`` it specifies that only distinct values of the field in "
"question are to be counted."
msgstr ""
"Il metodo ''count'' dell'oggetto Field ha un argomento opzionale ''distinct''. "
"Quando è impostato su ''True'' specifica che devono essere conteggiati solo i "
"valori distinti del campo in questione."

#: ../../chapter-07.rst:3221
msgid "Many to many relation"
msgstr "Relazione molti a molti"

#: ../../chapter-07.rst:3223
msgid ""
"In the previous examples, we allowed a thing to have one owner but one person "
"could have many things. What if Boat was owned by Alex and Curt? This requires "
"a many-to-many relation, and it is realized via an intermediate table that "
"links a person to a thing via an ownership relation."
msgstr ""
"Negli esempi precedenti, abbiamo permesso a una cosa di avere un proprietario, "
"ma una persona potrebbe avere molte cose. E se Boat fosse di proprietà di Alex "
"e Curt? Ciò richiede una relazione molti-a-molti e si realizza tramite una "
"tabella intermedia che collega una persona a una cosa tramite una relazione di "
"proprietà."

#: ../../chapter-07.rst:3229
msgid "Here is how to do it:"
msgstr "Ecco come farlo:"

#: ../../chapter-07.rst:3248
msgid "the existing ownership relationship can now be rewritten as:"
msgstr "La relazione di proprietà esistente può ora essere riscritta come:"

#: ../../chapter-07.rst:3259
msgid "Now you can add the new relation that Curt co-owns Boat:"
msgstr ""
"A questo punto è possibile aggiungere la nuova relazione di cui Curt è co-"
"proprietario Boat:"

#: ../../chapter-07.rst:3266
msgid ""
"Because you now have a three-way relation between tables, it may be convenient "
"to define a new set on which to perform operations:"
msgstr ""
"Poiché ora si dispone di una relazione a tre vie tra le tabelle, può essere "
"utile definire un nuovo set su cui eseguire le operazioni:"

#: ../../chapter-07.rst:3274
msgid "Now it is easy to select all persons and their things from the new Set:"
msgstr "Ora è facile selezionare tutte le persone e le loro cose dal nuovo Set:"

#: ../../chapter-07.rst:3286
msgid "Similarly, you can search for all things owned by Alex:"
msgstr "Allo stesso modo, puoi cercare tutte le cose di proprietà di Alex:"

#: ../../chapter-07.rst:3296
msgid "and all owners of Boat:"
msgstr "e tutti i proprietari di Boat:"

#: ../../chapter-07.rst:3306
msgid ""
"A lighter alternative to many-to-many relations is tagging, you can found an "
"example of this in the next section. Tagging works even on database backends "
"that do not support JOINs like the Google App Engine NoSQL."
msgstr ""
"Un'alternativa più semplice alle relazioni molti-a-molti è l'assegnazione di "
"tag, di cui puoi trovare un esempio nella prossima sezione. La codifica "
"funziona anche sui backend di database che non supportano i JOIN come Google "
"App Engine NoSQL."

#: ../../chapter-07.rst:3312
msgid "Self-Reference and aliases"
msgstr "Autoreferenzialità e alias"

#: ../../chapter-07.rst:3314
msgid ""
"It is possible to define tables with fields that refer to themselves, here is "
"an example:"
msgstr ""
"E' possibile definire tabelle con campi che fanno riferimento a se stessi, ecco "
"un esempio:"

#: ../../chapter-07.rst:3324
msgid ""
"Notice that the alternative notation of using a table object as field type will "
"fail in this case, because it uses a table before it is defined:"
msgstr ""
"Si noti che la notazione alternativa di utilizzo di un oggetto tabella come "
"tipo di campo avrà esito negativo in questo caso, perché utilizza una tabella "
"prima che venga definita:"

#: ../../chapter-07.rst:3335
msgid ""
"In general ``db.tablename`` and ``'reference tablename'`` are equivalent field "
"types, but the latter is the only one allowed for self-references."
msgstr ""
"In generale ''db.tablename'' e '''reference tablename''' sono tipi di campo "
"equivalenti, ma quest'ultimo è l'unico consentito per gli autoriferimenti."

#: ../../chapter-07.rst:3338
msgid ""
"When a table has a self-reference and you have to do join, for example to "
"select a person and its father, you need an alias for the table. In SQL an "
"alias is a temporary alternate name you can use to reference a table/column "
"into a query (or other SQL statement)."
msgstr ""
"Quando una tabella ha un autoreferenzialità e devi fare join, ad esempio per "
"selezionare una persona e suo padre, hai bisogno di un alias per la tabella. In "
"SQL, un alias è un nome alternativo temporaneo che è possibile utilizzare per "
"fare riferimento a una tabella/colonna in una query (o in un'altra istruzione "
"SQL)."

#: ../../chapter-07.rst:3343
msgid ""
"With py4web you can make an alias for a table using the ``with_alias`` method. "
"This works also for expressions, which means also for fields since ``Field`` is "
"derived from ``Expression``."
msgstr ""
"Con py4web è possibile creare un alias per una tabella usando il metodo "
"''with_alias''. Questo funziona anche per le espressioni, il che significa "
"anche per i campi poiché ''Field'' è derivato da ''Expression''."

#: ../../chapter-07.rst:3370
msgid ""
"Notice that we have chosen to make a distinction between: - “father_id”: the "
"field name used in the table “person”; - “father”: the alias we want to use for "
"the table referenced by the above field; this is communicated to the database; "
"- “Father”: the variable used by py4web to refer to that alias."
msgstr ""
"Si noti che si è scelto di fare una distinzione tra: - \"father_id\": il nome "
"del campo utilizzato nella tabella \"persona\"; - \"father\": l'alias che "
"vogliamo usare per la tabella a cui fa riferimento il campo precedente; ciò "
"viene comunicato alla banca dati; - \"Father\": la variabile usata da py4web "
"per riferirsi a quell'alias."

#: ../../chapter-07.rst:3376
msgid ""
"The difference is subtle, and there is nothing wrong in using the same name for "
"the three of them:"
msgstr ""
"La differenza è sottile e non c'è niente di sbagliato nell'usare lo stesso nome "
"per loro tre:"

#: ../../chapter-07.rst:3401
msgid ""
"But it is important to have the distinction clear in order to build correct "
"queries."
msgstr ""
"Ma è importante che la distinzione sia chiara per costruire query corrette."

#: ../../chapter-07.rst:3406
msgid "Other operators"
msgstr "Altri operatori"

#: ../../chapter-07.rst:3408
msgid ""
"py4web has other operators that provide an API to access equivalent SQL "
"operators. Let’s define another table “log” to store security events, their "
"event_time and severity, where the severity is an integer number."
msgstr ""
"py4web dispone di altri operatori che forniscono un'API per accedere a "
"operatori SQL equivalenti. Definiamo un'altra tabella \"log\" per memorizzare "
"gli eventi di sicurezza, la loro event_time e gravità, dove la gravità è un "
"numero intero."

#: ../../chapter-07.rst:3419
msgid ""
"As before, insert a few events, a “port scan”, an “xss injection” and an "
"“unauthorized login”. For the sake of the example, you can log events with the "
"same event_time but with different severities (1, 2, and 3 respectively)."
msgstr ""
"Come prima, inserisci alcuni eventi, una \"scansione della porta\", "
"un'\"iniezione xss\" e un \"accesso non autorizzato\". Ai fini dell'esempio, è "
"possibile registrare eventi con lo stesso event_time ma con gravità diverse "
"(rispettivamente 1, 2 e 3)."

#: ../../chapter-07.rst:3436
msgid ""
"``like``, ``ilike``, ``regexp``, ``startswith``, ``endswith``, ``contains``, "
"``upper``, ``lower``"
msgstr ""
"''Mi piace'', ''Mi piace'', ''Regexp'', ''Inizia con'', ''Finisce con'', "
"''Contiene'', ''Superiore'', ''Inferiore''"

#: ../../chapter-07.rst:3438
msgid "Fields have a ``like`` operator that you can use to match strings:"
msgstr ""
"I campi hanno un operatore ''like'' che puoi usare per trovare le stringhe:"

#: ../../chapter-07.rst:3447
msgid ""
"Here “port%” indicates a string starting with “port”. The percent sign "
"character, “%”, is a wild-card character that means “any sequence of "
"characters”."
msgstr ""
"Qui \"port%\" indica una stringa che inizia con \"port\". Il carattere del "
"segno di percentuale, \"%\", è un carattere jolly che indica \"qualsiasi "
"sequenza di caratteri\"."

#: ../../chapter-07.rst:3451
msgid ""
"The ``like`` operator maps to the LIKE word in ANSI-SQL. LIKE is case-sensitive "
"in most databases, and depends on the collation of the database itself. The "
"``like`` method is hence case-sensitive but it can be made case-insensitive with"
msgstr ""
"L'operatore ''like'' viene mappato alla parola LIKE in ANSI-SQL. LIKE fa "
"distinzione tra maiuscole e minuscole nella maggior parte dei database e "
"dipende dalle regole di confronto del database stesso. Il metodo ''like'' è "
"quindi sensibile alle maiuscole e alle minuscole, ma può essere reso "
"insensibile alle maiuscole e alle minuscole con"

#: ../../chapter-07.rst:3460
msgid "which is the same as using ``ilike``"
msgstr "che è lo stesso che usare ''ilike''"

#: ../../chapter-07.rst:3466
msgid "py4web also provides some shortcuts:"
msgstr "py4web fornisce anche alcune scorciatoie:"

#: ../../chapter-07.rst:3474
msgid "which are roughly equivalent respectively to"
msgstr "che sono all'incirca equivalenti rispettivamente a"

#: ../../chapter-07.rst:3482
msgid ""
"Remember that ``contains`` has a special meaning for ``list:<type>`` fields, as "
"discussed in :ref:`list_type and contains`."
msgstr ""
"Ricordate che ''contiene'' ha un significato speciale per i campi ''list:"
"<type>'', come discusso in :ref:'list_type e contiene''.</type>"

#: ../../chapter-07.rst:3485
msgid ""
"The ``contains`` method can also be passed a list of values and an optional "
"boolean argument ``all`` to search for records that contain all values:"
msgstr ""
"Al metodo ''contains'' può anche essere passata una lista di valori e un "
"argomento booleano opzionale ''all'' per cercare i record che contengono tutti "
"i valori:"

#: ../../chapter-07.rst:3493
msgid "or any value from the list"
msgstr "o qualsiasi valore dell'elenco"

#: ../../chapter-07.rst:3499
msgid ""
"There is a also a ``regexp`` method that works like the ``like`` method but "
"allows regular expression syntax for the look-up expression. It is only "
"supported by MySQL, Oracle, PostgreSQL, SQLite, and MongoDB (with different "
"degree of support)."
msgstr ""
"C'è anche un metodo ''regexp'' che funziona come il metodo ''like'' ma permette "
"la sintassi delle espressioni regolari per l'espressione di ricerca. È "
"supportato solo da MySQL, Oracle, PostgreSQL, SQLite e MongoDB (con diversi "
"gradi di supporto)."

#: ../../chapter-07.rst:3504
msgid ""
"The ``upper`` and ``lower`` methods allow you to convert the value of the field "
"to upper or lower case, and you can also combine them with the like operator:"
msgstr ""
"I metodi ''upper'' e ''lower'' ti permettono di convertire il valore del campo "
"in maiuscolo o minuscolo, e puoi anche combinarli con l'operatore like:"

#: ../../chapter-07.rst:3516
msgid "``year``, ``month``, ``day``, ``hour``, ``minutes``, ``seconds``"
msgstr "''anno'', ''mese'', ''giorno'', ''ora'', ''minuti'', ''secondi''"

#: ../../chapter-07.rst:3518
msgid ""
"The date and datetime fields have ``day``, ``month`` and ``year`` methods. The "
"datetime and time fields have ``hour``, ``minutes`` and ``seconds`` methods. "
"Here is an example:"
msgstr ""
"I campi date e datetime hanno i metodi ''day'', ''month'' e ''year''. I campi "
"datetime e time hanno i metodi ''hour'', ''minutes'' e ''seconds''. Ecco un "
"esempio:"

#: ../../chapter-07.rst:3532
msgid "``belongs``"
msgstr "''appartiene''"

#: ../../chapter-07.rst:3534
msgid ""
"The SQL IN operator is realized via the ``belongs`` method which returns true "
"when the field value belongs to the specified set (list or tuples):"
msgstr ""
"L'operatore SQL IN è realizzato tramite il metodo ''belongs'' che restituisce "
"true quando il valore del campo appartiene all'insieme specificato (lista o "
"tuple):"

#: ../../chapter-07.rst:3545
msgid ""
"The DAL also allows a nested select as the argument of the belongs operator. "
"The only caveat is that the nested select has to be a ``_select``, not a "
"``select``, and only one field has to be selected explicitly, the one that "
"defines the set."
msgstr ""
"Il DAL consente anche una selezione nidificata come argomento dell'operatore "
"appartene. L'unica avvertenza è che la selezione nidificata deve essere un "
"''_select'', non un ''select'', e solo un campo deve essere selezionato "
"esplicitamente, quello che definisce l'insieme."

#: ../../chapter-07.rst:3560
msgid ""
"In those cases where a nested select is required and the look-up field is a "
"reference we can also use a query as argument. For example:"
msgstr ""
"Nei casi in cui è richiesta una selezione nidificata e il campo di ricerca è un "
"riferimento, è possibile utilizzare anche una query come argomento. Per esempio:"

#: ../../chapter-07.rst:3572
msgid ""
"In this case it is obvious that the nested select only needs the field "
"referenced by the ``db.thing.owner_id`` field so we do not need the more "
"verbose ``_select`` notation."
msgstr ""
"In questo caso è ovvio che la selezione nidificata ha bisogno solo del campo a "
"cui fa riferimento il campo ''db.thing.owner_id'', quindi non abbiamo bisogno "
"della notazione ''_select'' più dettagliata."

#: ../../chapter-07.rst:3576
msgid ""
"A nested select can also be used as insert/update value but in this case the "
"syntax is different:"
msgstr ""
"Una selezione nidificata può essere utilizzata anche come valore di inserimento/"
"aggiornamento, ma in questo caso la sintassi è diversa:"

#: ../../chapter-07.rst:3585
msgid ""
"In this case ``lazy`` is a nested expression that computes the ``id`` of person "
"“Jonathan”. The two lines result in one single SQL query."
msgstr ""
"In questo caso ''lazy'' è un'espressione nidificata che calcola l''id'' della "
"persona ''Jonathan''. Le due righe generano un'unica query SQL."

#: ../../chapter-07.rst:3589
msgid "``sum``, ``avg``, ``min``, ``max`` and ``len``"
msgstr "''Somma'', ''Media'', ''Min'', ''Max'' e ''Len''"

#: ../../chapter-07.rst:3591
msgid ""
"Previously, you have used the ``count`` operator to count records. Similarly, "
"you can use the ``sum`` operator to add (sum) the values of a specific field "
"from a group of records. As in the case of count, the result of a sum is "
"retrieved via the storage object:"
msgstr ""
"In precedenza, è stato utilizzato l'operatore ''count'' per contare i record. "
"Allo stesso modo, è possibile utilizzare l'operatore ''sum'' per aggiungere "
"(sommare) i valori di un campo specifico da un gruppo di record. Come nel caso "
"di count, il risultato di una somma viene recuperato tramite l'oggetto di "
"archiviazione:"

#: ../../chapter-07.rst:3602
msgid ""
"You can also use ``avg``, ``min``, and ``max`` to the average, minimum, and "
"maximum value respectively for the selected records. For example:"
msgstr ""
"È inoltre possibile utilizzare ''avg'', ''min'' e ''max'' rispettivamente per "
"il valore medio, minimo e massimo per i record selezionati. Per esempio:"

#: ../../chapter-07.rst:3611
msgid ""
"``len`` computes the length of field’s value. It is generally used on string or "
"text fields but depending on the back-end it may still work for other types too "
"(boolean, integer, etc)."
msgstr ""
"''len'' calcola la lunghezza del valore del campo. Viene generalmente "
"utilizzato su campi stringa o di testo, ma a seconda del back-end può "
"funzionare anche per altri tipi (booleani, interi, ecc.)."

#: ../../chapter-07.rst:3622
msgid ""
"Expressions can be combined to form more complex expressions. For example here "
"we are computing the sum of the length of the event strings in the logs plus "
"one:"
msgstr ""
"Le espressioni possono essere combinate per formare espressioni più complesse. "
"Ad esempio, qui calcoliamo la somma della lunghezza delle stringhe di evento "
"nei log più uno:"

#: ../../chapter-07.rst:3633
msgid "Substrings"
msgstr "Sottostringhe"

#: ../../chapter-07.rst:3635
msgid ""
"One can build an expression to refer to a substring. For example, we can group "
"things whose name starts with the same three characters and select only one "
"from each group:"
msgstr ""
"È possibile creare un'espressione per fare riferimento a una sottostringa. Ad "
"esempio, possiamo raggruppare le cose il cui nome inizia con gli stessi tre "
"caratteri e selezionarne solo uno da ogni gruppo:"

#: ../../chapter-07.rst:3644
msgid "Default values with ``coalesce`` and ``coalesce_zero``"
msgstr "Valori predefiniti con ''coalesce'' e ''coalesce_zero''"

#: ../../chapter-07.rst:3646
msgid ""
"There are times when you need to pull a value from database but also need a "
"default values if the value for a record is set to NULL. In SQL there is a "
"function, ``COALESCE``, for this. py4web has an equivalent ``coalesce`` method:"
msgstr ""
"In alcuni casi è necessario estrarre un valore dal database, ma è anche "
"necessario un valore predefinito se il valore di un record è impostato su NULL. "
"In SQL c'è una funzione, ''COALESCE'', per questo. py4web ha un metodo "
"''coalesce'' equivalente:"

#: ../../chapter-07.rst:3666
msgid ""
"Other times you need to compute a mathematical expression but some fields have "
"a value set to None while it should be zero. ``coalesce_zero`` comes to the "
"rescue by defaulting None to zero in the query:"
msgstr ""
"Altre volte è necessario calcolare un'espressione matematica, ma alcuni campi "
"hanno un valore impostato su None mentre dovrebbe essere zero. "
"''coalesce_zero'' viene in soccorso impostando il valore predefinito di None su "
"zero nella query:"

#: ../../chapter-07.rst:3689
msgid "Exporting and importing data"
msgstr "Esportazione e importazione di dati"

#: ../../chapter-07.rst:3692
msgid "CSV (one Table at a time)"
msgstr "CSV (una tabella alla volta)"

#: ../../chapter-07.rst:3694
msgid ""
"When a Rows object is converted to a string it is automatically serialized in "
"CSV:"
msgstr ""
"Quando un oggetto Rows viene convertito in una stringa, viene serializzato "
"automaticamente in CSV:"

#: ../../chapter-07.rst:3706
msgid "You can serialize a single table in CSV and store it in a file “test.csv”:"
msgstr ""
"È possibile serializzare una singola tabella in CSV e memorizzarla in un file "
"\"test.csv\":"

#: ../../chapter-07.rst:3715
msgid ""
"Converting a ``Rows`` object into a string produces an encoded binary string "
"and it's better to be explicit with the encoding used:"
msgstr ""
"La conversione di un oggetto ''Rows'' in una stringa produce una stringa "
"binaria codificata ed è meglio essere espliciti con la codifica utilizzata:"

#: ../../chapter-07.rst:3723
msgid "This is equivalent to"
msgstr "Ciò equivale a"

#: ../../chapter-07.rst:3731
msgid "You can read the CSV file back with:"
msgstr "Puoi rileggere il file CSV con:"

#: ../../chapter-07.rst:3738
msgid "Again, you can be explict about the encoding for the exporting file:"
msgstr ""
"Anche in questo caso, è possibile specificare in modo esplicito la codifica del "
"file di esportazione:"

#: ../../chapter-07.rst:3747
msgid "and the importing one:"
msgstr "e quello importatore:"

#: ../../chapter-07.rst:3754
msgid ""
"When importing, py4web looks for the field names in the CSV header. In this "
"example, it finds two columns: “person.id” and “person.name”. It ignores the "
"“person.” prefix, and it ignores the “id” fields. Then all records are appended "
"and assigned new ids."
msgstr ""
"Durante l'importazione, py4web cerca i nomi dei campi nell'intestazione CSV. In "
"questo esempio, trova due colonne: \"person.id\" e \"person.name\". Ignora il "
"prefisso \"person.\" e ignora i campi \"id\". Quindi tutti i record vengono "
"aggiunti e assegnati nuovi ID."

#: ../../chapter-07.rst:3760
msgid "CSV (all tables at once)"
msgstr "CSV (tutte le tabelle contemporaneamente)"

#: ../../chapter-07.rst:3762
msgid "In py4web, you can backup/restore an entire database with two commands:"
msgstr ""
"In py4web, è possibile eseguire il backup/ripristino di un intero database con "
"due comandi:"

#: ../../chapter-07.rst:3764
msgid "To export:"
msgstr "Per esportare:"

#: ../../chapter-07.rst:3771
msgid "To import:"
msgstr "Per importare:"

#: ../../chapter-07.rst:3778
msgid ""
"This mechanism can be used even if the importing database is of a different "
"type than the exporting database."
msgstr ""
"Questo meccanismo può essere utilizzato anche se il database di importazione è "
"di tipo diverso da quello di esportazione."

#: ../../chapter-07.rst:3781
msgid ""
"The data is stored in “somefile.csv” as a CSV file where each table starts with "
"one line that indicates the tablename, and another line with the fieldnames:"
msgstr ""
"I dati vengono memorizzati in \"somefile.csv\" come file CSV in cui ogni "
"tabella inizia con una riga che indica il nome della tabella e un'altra riga "
"con i nomi dei campi:"

#: ../../chapter-07.rst:3790
msgid ""
"Two tables are separated by ``\\r\\n\\r\\n`` (that is two empty lines). The "
"file ends with the line"
msgstr ""
"Due tabelle sono separate da ''\\r\\n\\r\\n'' (cioè due righe vuote). Il file "
"termina con la riga"

#: ../../chapter-07.rst:3797
msgid ""
"The file does not include uploaded files if these are not stored in the "
"database. The upload files stored on filesystem must be dumped separately, a "
"zip of the “uploads” folder may suffice in most cases."
msgstr ""
"Il file non include i file caricati se questi non sono memorizzati nel "
"database. I file di caricamento memorizzati sul filesystem devono essere "
"scaricati separatamente, uno zip della cartella \"uploads\" può essere "
"sufficiente nella maggior parte dei casi."

#: ../../chapter-07.rst:3801
msgid ""
"When importing, the new records will be appended to the database if it is not "
"empty. In general the new imported records will not have the same record id as "
"the original (saved) records but py4web will restore references so they are not "
"broken, even if the id values may change."
msgstr ""
"Durante l'importazione, i nuovi record verranno aggiunti al database se non è "
"vuoto. In generale, i nuovi record importati non avranno lo stesso id dei "
"record originali (salvati), ma py4web ripristinerà i riferimenti in modo che "
"non siano interrotti, anche se i valori id possono cambiare."

#: ../../chapter-07.rst:3806
msgid ""
"If a table contains a field called ``uuid``, this field will be used to "
"identify duplicates. Also, if an imported record has the same ``uuid`` as an "
"existing record, the previous record will be updated."
msgstr ""
"Se una tabella contiene un campo chiamato ''uuid'', questo campo verrà "
"utilizzato per identificare i duplicati. Inoltre, se un record importato ha lo "
"stesso ''uuid'' di un record esistente, il record precedente verrà aggiornato."

#: ../../chapter-07.rst:3811
msgid "CSV and remote database synchronization"
msgstr "CSV e sincronizzazione remota del database"

#: ../../chapter-07.rst:3813
msgid "Consider once again the following model:"
msgstr "Si consideri ancora una volta il seguente modello:"

#: ../../chapter-07.rst:3829
msgid ""
"Each record is identified by an identifier and referenced by that id. If you "
"have two copies of the database used by distinct py4web installations, the id "
"is unique only within each database and not across the databases. This is a "
"problem when merging records from different databases."
msgstr ""
"Ogni record è identificato da un identificatore e vi fa riferimento tale id. Se "
"si dispone di due copie del database utilizzate da installazioni py4web "
"distinte, l'id è univoco solo all'interno di ciascun database e non tra i "
"database. Questo è un problema quando si uniscono record di database diversi."

#: ../../chapter-07.rst:3835
msgid ""
"In order to make records uniquely identifiable across databases, they must: - "
"have a unique id (UUID), - have a last modification time to track the most "
"recent among multiple copies, - reference the UUID instead of the id."
msgstr ""
"Al fine di rendere i record identificabili in modo univoco tra i database, "
"devono: - avere un ID univoco (UUID), - avere una data dell'ultima modifica per "
"tenere traccia del più recente tra più copie, - fare riferimento all'UUID "
"anziché all'ID."

#: ../../chapter-07.rst:3840
msgid "This can be achieved changing the above model into:"
msgstr "Ciò può essere ottenuto modificando il modello di cui sopra in:"

#: ../../chapter-07.rst:3872
msgid ""
"Notice that in the above table definitions, the default value for the two "
"``uuid`` fields is set to a lambda function, which returns a UUID (converted to "
"a string). The lambda function is called once for each record inserted, "
"ensuring that each record gets a unique UUID, even if multiple records are "
"inserted in a single transaction."
msgstr ""
"Si noti che nelle definizioni della tabella precedente, il valore predefinito "
"per i due campi ''uuid'' è impostato su una funzione lambda, che restituisce un "
"UUID (convertito in una stringa). La funzione lambda viene chiamata una volta "
"per ogni record inserito, assicurando che ogni record ottenga un UUID univoco, "
"anche se più record vengono inseriti in una singola transazione."

#: ../../chapter-07.rst:3878
msgid "Create a controller action to export the database:"
msgstr "Creare un'azione del controller per esportare il database:"

#: ../../chapter-07.rst:3890
msgid ""
"Create a controller action to import a saved copy of the other database and "
"sync records:"
msgstr ""
"Creare un'azione del controller per importare una copia salvata dell'altro "
"database e sincronizzare i record:"

#: ../../chapter-07.rst:3914
msgid ""
"Optionally you should create an index manually to make the search by uuid "
"faster."
msgstr ""
"Facoltativamente, è necessario creare manualmente un indice per rendere più "
"veloce la ricerca in base all'uuid."

#: ../../chapter-07.rst:3917
msgid "Alternatively, you can use XML-RPC to export/import the file."
msgstr ""
"In alternativa, è possibile utilizzare XML-RPC per esportare/importare il file."

#: ../../chapter-07.rst:3919
msgid ""
"If the records reference uploaded files, you also need to export/import the "
"content of the uploads folder. Notice that files therein are already labeled by "
"UUIDs so you do not need to worry about naming conflicts and references."
msgstr ""
"Se i record fanno riferimento a file caricati, è necessario esportare/importare "
"anche il contenuto della cartella dei caricamenti. Si noti che i file in esso "
"contenuti sono già etichettati dagli UUID, quindi non è necessario preoccuparsi "
"di conflitti di denominazione e riferimenti."

#: ../../chapter-07.rst:3925
msgid "HTML and XML (one Table at a time)"
msgstr "HTML e XML (una tabella alla volta)"

#: ../../chapter-07.rst:3927
msgid ""
"Rows objects also have an ``xml`` method (like helpers) that serializes it to "
"XML/HTML:"
msgstr ""
"Gli oggetti Rows hanno anche un metodo ''xml'' (come gli helper) che li "
"serializza in XML/HTML:"

#: ../../chapter-07.rst:3964
msgid ""
"If you need to serialize the Rows in any other XML format with custom tags, you "
"can easily do that using the universal :ref:`TAG` helper that we'll see later "
"and the Python syntax ``*<iterable>`` allowed in function calls:"
msgstr ""
"Se hai bisogno di serializzare le righe in qualsiasi altro formato XML con tag "
"personalizzati, puoi farlo facilmente usando l'helper universale :ref:'TAG' che "
"vedremo più avanti e la sintassi Python ''*<iterable>'' consentita nelle "
"chiamate di funzione:</iterable>"

#: ../../chapter-07.rst:3983
msgid "Data representation"
msgstr "Rappresentazione dei dati"

#: ../../chapter-07.rst:3985
msgid ""
"The ``Rows.export_to_csv_file`` method accepts a keyword argument named "
"``represent``. When ``True`` it will use the columns ``represent`` function "
"while exporting the data instead of the raw data."
msgstr ""
"Il metodo ''Rows.export_to_csv_file'' accetta un argomento di parola chiave "
"chiamato ''represent''. Quando è ''True'' userà la funzione ''represent'' delle "
"colonne durante l'esportazione dei dati invece dei dati grezzi."

#: ../../chapter-07.rst:3989
msgid ""
"The function also accepts a keyword argument named ``colnames`` that should "
"contain a list of column names one wish to export. It defaults to all columns."
msgstr ""
"La funzione accetta anche un argomento di parola chiave chiamato ''colnames'' "
"che dovrebbe contenere un elenco di nomi di colonna che si desidera esportare. "
"Il valore predefinito è tutte le colonne."

#: ../../chapter-07.rst:3993
msgid ""
"Both ``export_to_csv_file`` and ``import_from_csv_file`` accept keyword "
"arguments that tell the csv parser the format to save/load the files: - "
"``delimiter``: delimiter to separate values (default ‘,’) - ``quotechar``: "
"character to use to quote string values (default to double quotes) - "
"``quoting``: quote system (default ``csv.QUOTE_MINIMAL``)"
msgstr ""
"Sia ''export_to_csv_file'' che ''import_from_csv_file'' accettano argomenti di "
"parole chiave che indicano al parser csv il formato per salvare/caricare i "
"file: - ''delimitatore'': delimitatore per separare i valori (default ',') - "
"''quotechar'': carattere da usare per citare i valori delle stringhe (il valore "
"predefinito è quello delle virgolette doppie) - ''quoting'': sistema di "
"virgolette (default ''csv. QUOTE_MINIMAL'')"

#: ../../chapter-07.rst:4000
msgid "Here is some example usage:"
msgstr "Di seguito sono riportati alcuni esempi di utilizzo:"

#: ../../chapter-07.rst:4012
msgid "Which would render something similar to"
msgstr "Il che renderebbe qualcosa di simile a"

#: ../../chapter-07.rst:4018
msgid "For more information consult the official Python documentation"
msgstr "Per maggiori informazioni consulta la documentazione ufficiale di Python"

#: ../../chapter-07.rst:4022
msgid "Advanced features"
msgstr "Funzionalità avanzate"

#: ../../chapter-07.rst:4027
msgid "``list:<type>`` and ``contains``"
msgstr "''elenco:<type>'' e ''contiene''</type>"

#: ../../chapter-07.rst:4029
msgid "py4web provides the following special field types:"
msgstr "py4web fornisce i seguenti tipi di campi speciali:"

#: ../../chapter-07.rst:4037
msgid ""
"They can contain lists of strings, of integers and of references respectively."
msgstr ""
"Possono contenere rispettivamente liste di stringhe, di numeri interi e di "
"riferimenti."

#: ../../chapter-07.rst:4040
msgid ""
"On Google App Engine NoSQL ``list:string`` is mapped into "
"``StringListProperty``, the other two are mapped into ``ListProperty(int)``. On "
"relational databases they are mapped into text fields which contain the list of "
"items separated by ``|``. For example ``[1, 2, 3]`` is mapped into ``|1|2|3|``."
msgstr ""
"Su Google App Engine NoSQL ''list:string'' è mappato in ''StringListProperty'', "
"gli altri due sono mappati in ''ListProperty(int)''. Nei database relazionali "
"sono mappati in campi di testo che contengono l'elenco degli elementi separati "
"da ''|''. Per esempio ''[1, 2, 3]'' è mappato in ''|1|2|3|''."

#: ../../chapter-07.rst:4046
msgid ""
"For lists of string the items are escaped so that any ``|`` in the item is "
"replaced by a ``||``. Anyway this is an internal representation and it is "
"transparent to the user."
msgstr ""
"Per gli elenchi di stringhe, gli elementi vengono preceduti da un carattere di "
"escape in modo che qualsiasi ''|'' nell'elemento venga sostituito da un ''||``. "
"In ogni caso si tratta di una rappresentazione interna ed è trasparente per "
"l'utente."

#: ../../chapter-07.rst:4050
msgid "You can use ``list:string``, for example, in the following way:"
msgstr "Si può usare ''list:string'', per esempio, nel modo seguente:"

#: ../../chapter-07.rst:4067
msgid "``list:integer`` works in the same way but the items must be integers."
msgstr ""
"''list:integer'' funziona allo stesso modo, ma gli elementi devono essere "
"interi."

#: ../../chapter-07.rst:4069
msgid ""
"As usual the requirements are enforced at the level of forms, not at the level "
"of ``insert``."
msgstr ""
"Come al solito i requisiti sono applicati a livello di moduli, non a livello di "
"''inserimento''."

#: ../../chapter-07.rst:4072
msgid ""
"For ``list:<type>`` fields the ``contains(value)`` operator maps into a non "
"trivial query that checks for lists containing the ``value``. The ``contains`` "
"operator also works for regular ``string`` and ``text`` fields and it maps into "
"a ``LIKE '%value%'``."
msgstr ""
"Per i campi ''list:<type>'' l'operatore ''contains(value)'' viene mappato in "
"una query non banale che controlla le liste contenenti il ''value''. "
"L'operatore ''contains'' funziona anche per i normali campi ''stringa'' e "
"''testo'' e viene mappato in un ''LIKE '%value%'''.</type>"

#: ../../chapter-07.rst:4077
msgid ""
"The ``list:reference`` and the ``contains(value)`` operator are particularly "
"useful to de-normalize many-to-many relations. Here is an example:"
msgstr ""
"L'operatore ''list:reference'' e l'operatore ''contains(value)'' sono "
"particolarmente utili per denormalizzare le relazioni molti-a-molti. Ecco un "
"esempio:"

#: ../../chapter-07.rst:4106
msgid "Notice that a ``list:reference tag`` field get a default constraint"
msgstr "Si noti che un campo ''list:reference tag'' ha un vincolo predefinito"

#: ../../chapter-07.rst:4112
msgid "that produces a ``SELECT/OPTION`` multiple drop-box in forms."
msgstr "che produce una casella a discesa multipla ''SELECT/OPTION'' nei moduli."

#: ../../chapter-07.rst:4114
msgid ""
"Also notice that this field gets a default ``represent`` attribute which "
"represents the list of references as a comma-separated list of formatted "
"references. This is used in read ``forms``."
msgstr ""
"Si noti inoltre che questo campo ottiene un attributo predefinito ''represent'' "
"che rappresenta l'elenco dei riferimenti come un elenco separato da virgole di "
"riferimenti formattati. Questo è usato in ''forms'' di lettura."

#: ../../chapter-07.rst:4118
msgid ""
"While ``list:reference`` has a default validator and a default representation, "
"``list:integer`` and ``list:string`` do not. So these two need an ``IS_IN_SET`` "
"or an ``IS_IN_DB`` validator if you want to use them in forms."
msgstr ""
"Mentre ''list:reference'' ha un validatore predefinito e una rappresentazione "
"predefinita, ''list:integer'' e ''list:string'' non lo fanno. Quindi questi due "
"hanno bisogno di un validatore ''IS_IN_SET'' o ''IS_IN_DB'' se vuoi usarli nei "
"moduli."

#: ../../chapter-07.rst:4125
msgid "Table inheritance"
msgstr "Ereditarietà delle tabelle"

#: ../../chapter-07.rst:4127
msgid ""
"It is possible to create a table that contains all the fields from another "
"table. It is sufficient to pass the other table in place of a field to "
"``define_table``. For example"
msgstr ""
"È possibile creare una tabella che contiene tutti i campi di un'altra tabella. "
"E' sufficiente passare l'altra tabella al posto di un campo a ''define_table''. "
"Per esempio"

#: ../../chapter-07.rst:4138
msgid ""
"It is also possible to define a dummy table that is not stored in a database in "
"order to reuse it in multiple other places. For example:"
msgstr ""
"È anche possibile definire una tabella fittizia che non è memorizzata in un "
"database per riutilizzarla in più altre posizioni. Per esempio:"

#: ../../chapter-07.rst:4154
msgid "This example assumes that standard py4web authentication is enabled."
msgstr ""
"In questo esempio si presuppone che l'autenticazione py4web standard sia "
"abilitata."

#: ../../chapter-07.rst:4156
msgid ""
"Notice that if you use ``Auth`` py4web already creates one such table for you:"
msgstr ""
"Notate che se usate ''Auth'' py4web crea già una di queste tabelle per voi:"

#: ../../chapter-07.rst:4164
msgid ""
"When using table inheritance, if you want the inheriting table to inherit "
"validators, be sure to define the validators of the parent table before "
"defining the inheriting table."
msgstr ""
"Quando si utilizza l'ereditarietà delle tabelle, se si desidera che la tabella "
"ereditaria erediti i validatori, assicurarsi di definire i validatori della "
"tabella padre prima di definire la tabella ereditaria."

#: ../../chapter-07.rst:4171
msgid "``filter_in`` and ``filter_out``"
msgstr "''filter_in'' e ''filter_out''"

#: ../../chapter-07.rst:4173
msgid ""
"It is possible to define a filter for each field to be called before a value is "
"inserted into the database for that field and after a value is retrieved from "
"the database."
msgstr ""
"È possibile definire un filtro per ogni campo da chiamare prima che un valore "
"venga inserito nel database per quel campo e dopo che un valore viene "
"recuperato dal database."

#: ../../chapter-07.rst:4177
msgid ""
"Imagine for example that you want to store a serializable Python data structure "
"in a field in the JSON format. Here is how it could be accomplished:"
msgstr ""
"Si supponga, ad esempio, di voler archiviare una struttura di dati Python "
"serializzabile in un campo in formato JSON. Ecco come potrebbe essere "
"realizzato:"

#: ../../chapter-07.rst:4196
msgid ""
"Another way to accomplish the same is by using a Field of type "
"``SQLCustomType``, as discussed in :ref:`Custom Field types`."
msgstr ""
"Un altro modo per ottenere lo stesso risultato è usare un campo di tipo "
"''SQLCustomType'', come discusso in :ref:'Custom Field types'."

#: ../../chapter-07.rst:4200
msgid "callbacks on record insert, delete and update"
msgstr "callback per l'inserimento, l'eliminazione e l'aggiornamento dei record"

#: ../../chapter-07.rst:4202
msgid ""
"PY4WEB provides a mechanism to register callbacks to be called before and/or "
"after insert, update and delete of records."
msgstr ""
"PY4WEB fornisce un meccanismo per registrare callback da chiamare prima e/o "
"dopo l'inserimento, l'aggiornamento e la cancellazione dei record."

#: ../../chapter-07.rst:4205
msgid "Each table stores six lists of callbacks:"
msgstr "Ogni tabella memorizza sei elenchi di callback:"

#: ../../chapter-07.rst:4216
msgid ""
"You can register a callback function by appending it to the corresponding list. "
"The caveat is that depending on the functionality, the callback has different "
"signature."
msgstr ""
"È possibile registrare una funzione di callback aggiungendola all'elenco "
"corrispondente. L'avvertenza è che, a seconda della funzionalità, il callback "
"ha una firma diversa."

#: ../../chapter-07.rst:4220
msgid "This is best explained by examples."
msgstr "Questo si spiega meglio con degli esempi."

#: ../../chapter-07.rst:4248
msgid ""
"As you can see: - ``f`` gets passed the ``OpRow`` object with data for insert "
"or update. - ``i`` gets passed the id of the newly inserted record. - ``s`` "
"gets passed the ``Set`` object used for update or delete. ``OpRow`` is an "
"helper object specialized in storing (field, value) pairs, you can think of it "
"as a normal dictionary that you can use even with the syntax of attribute "
"notation (that is ``f.name`` and ``f['name']`` are equivalent)."
msgstr ""
"Come si può vedere: - ''f'' viene passato all'oggetto ''OpRow'' con i dati per "
"l'inserimento o l'aggiornamento. - ''i'' viene passato l'id del record appena "
"inserito. - ''s'' viene passato all'oggetto ''Set'' usato per l'aggiornamento o "
"la cancellazione. ''OpRow'' è un oggetto helper specializzato nella "
"memorizzazione di coppie (campo, valore), puoi pensarlo come un normale "
"dizionario che puoi usare anche con la sintassi della notazione degli attributi "
"(cioè ''f.name'' e ''f['name']'' sono equivalenti)."

#: ../../chapter-07.rst:4256
msgid ""
"The return values of these callback should be ``None`` or ``False``. If any of "
"the ``_before_*`` callback returns a ``True`` value it will abort the actual "
"insert/update/delete operation."
msgstr ""
"I valori restituiti di questi callback dovrebbero essere ''None'' o ''False''. "
"Se uno qualsiasi dei callback ''_before_*'' restituisce un valore ''True'', "
"interromperà l'operazione di inserimento/aggiornamento/eliminazione effettiva."

#: ../../chapter-07.rst:4260
msgid ""
"Some times a callback may need to perform an update in the same or a different "
"table and one wants to avoid firing other callbacks, which could cause an "
"infinite loop."
msgstr ""
"A volte un callback potrebbe dover eseguire un aggiornamento nella stessa "
"tabella o in una tabella diversa e si desidera evitare di attivare altri "
"callback, che potrebbero causare un ciclo infinito."

#: ../../chapter-07.rst:4264
msgid ""
"For this purpose there the ``Set`` objects have an ``update_naive`` method that "
"works like ``update`` but ignores before and after callbacks."
msgstr ""
"A questo scopo gli oggetti ''Set'' hanno un metodo ''update_naive'' che "
"funziona come ''update'' ma ignora i callback prima e dopo."

#: ../../chapter-07.rst:4269
msgid "Database cascades"
msgstr "Cascate di database"

#: ../../chapter-07.rst:4271
msgid ""
"Database schema can define relationships which trigger deletions of related "
"records, known as cascading. The DAL is not informed when a record is deleted "
"due to a cascade. So no \\*_delete callback will ever be called as consequence "
"of a cascade-deletion."
msgstr ""
"Lo schema del database è in grado di definire relazioni che attivano "
"l'eliminazione di record correlati, nota come propagazione a cascata. Il DAL "
"non viene informato quando un record viene eliminato a causa di una "
"propagazione. Quindi nessun \\*_delete callback verrà mai chiamato come "
"conseguenza di una cancellazione a cascata."

#: ../../chapter-07.rst:4277
msgid "Record versioning"
msgstr "Controllo delle versioni dei record"

#: ../../chapter-07.rst:4279
msgid ""
"It is possible to ask py4web to save every copy of a record when the record is "
"individually modified. There are different ways to do it and it can be done for "
"all tables at once using the syntax:"
msgstr ""
"E' possibile chiedere a py4web di salvare ogni copia di un record quando il "
"record viene modificato singolarmente. Ci sono diversi modi per farlo e può "
"essere fatto per tutte le tabelle contemporaneamente usando la sintassi:"

#: ../../chapter-07.rst:4287
msgid ""
"this requires ``Auth``. It can also be done for each individual table as "
"discussed below."
msgstr ""
"questo richiede ''Auth''. Può anche essere fatto per ogni singola tabella, come "
"discusso di seguito."

#: ../../chapter-07.rst:4290
msgid "Consider the following table:"
msgstr "Si consideri la tabella seguente:"

#: ../../chapter-07.rst:4300
msgid ""
"Notice the hidden boolean field called ``is_active`` and defaulting to True."
msgstr ""
"Si noti il campo booleano nascosto chiamato ''is_active'' e il valore "
"predefinito è True."

#: ../../chapter-07.rst:4303
msgid ""
"We can tell py4web to create a new table (in the same or a different database) "
"and store all previous versions of each record in the table, when modified."
msgstr ""
"Possiamo dire a py4web di creare una nuova tabella (nello stesso database o in "
"un database diverso) e memorizzare tutte le versioni precedenti di ogni record "
"nella tabella, quando modificato."

#: ../../chapter-07.rst:4307
msgid "This is done in the following way:"
msgstr "Questa operazione viene eseguita nel modo seguente:"

#: ../../chapter-07.rst:4313
msgid "or in a more verbose syntax:"
msgstr "o in una sintassi più dettagliata:"

#: ../../chapter-07.rst:4322
msgid ""
"The ``archive_db=db`` tells py4web to store the archive table in the same "
"database as the ``stored_item`` table. The ``archive_name`` sets the name for "
"the archive table. The archive table has the same fields as the original table "
"``stored_item`` except that unique fields are no longer unique (because it "
"needs to store multiple versions) and has an extra field which name is "
"specified by ``current_record`` and which is a reference to the current record "
"in the ``stored_item`` table."
msgstr ""
"''archive_db=db'' dice a py4web di memorizzare la tabella di archivio nello "
"stesso database della tabella ''stored_item''. ''archive_name'' imposta il nome "
"per la tabella di archiviazione. La tabella dell'archivio ha gli stessi campi "
"della tabella originale ''stored_item'', tranne per il fatto che i campi "
"univoci non sono più univoci (perché deve memorizzare più versioni) e ha un "
"campo aggiuntivo il cui nome è specificato da ''current_record'' e che è un "
"riferimento al record corrente nella tabella ''stored_item''."

#: ../../chapter-07.rst:4330
msgid ""
"When records are deleted, they are not really deleted. A deleted record is "
"copied in the ``stored_item_archive`` table (like when it is modified) and the "
"``is_active`` field is set to False. By enabling record versioning py4web sets "
"a ``common_filter`` on this table that hides all records in table "
"``stored_item`` where the ``is_active`` field is set to False. The "
"``is_active`` parameter in the ``_enable_record_versioning`` method allows to "
"specify the name of the field used by the ``common_filter`` to determine if the "
"field was deleted or not."
msgstr ""
"Quando i record vengono eliminati, non vengono effettivamente eliminati. Un "
"record eliminato viene copiato nella tabella ''stored_item_archive'' (come "
"quando viene modificato) e il campo ''is_active'' viene impostato su False. "
"Abilitando il controllo delle versioni dei record, py4web imposta un "
"''common_filter'' su questa tabella che nasconde tutti i record nella tabella "
"''stored_item'' dove il campo ''is_active'' è impostato su False. Il parametro "
"''is_active'' nel metodo ''_enable_record_versioning'' permette di specificare "
"il nome del campo usato dal ''common_filter'' per determinare se il campo è "
"stato cancellato o meno."

#: ../../chapter-07.rst:4341
msgid "Common filters"
msgstr "Filtri comuni"

#: ../../chapter-07.rst:4343
msgid ""
"A common filter is a generalization of the above multi-tenancy idea. It "
"provides an easy way to prevent repeating of the same query. Consider for "
"example the following table:"
msgstr ""
"Un filtro comune è una generalizzazione dell'idea di multi-tenancy di cui "
"sopra. Fornisce un modo semplice per impedire la ripetizione della stessa "
"query. Si consideri, ad esempio, la seguente tabella:"

#: ../../chapter-07.rst:4355
msgid ""
"Any select, delete or update in this table, will include only public blog "
"posts. The attribute can also be modified at runtime:"
msgstr ""
"Qualsiasi selezione, eliminazione o aggiornamento in questa tabella includerà "
"solo i post pubblici del blog. L'attributo può essere modificato anche in fase "
"di esecuzione:"

#: ../../chapter-07.rst:4362
msgid ""
"It serves both as a way to avoid repeating the “db.blog_post.is_public==True” "
"phrase in each blog post search, and also as a security enhancement, that "
"prevents you from forgetting to disallow viewing of non-public posts."
msgstr ""
"Serve sia come un modo per evitare di ripetere la frase \"db.blog_post."
"is_public==True\" in ogni ricerca di post del blog, sia come miglioramento "
"della sicurezza, che ti impedisce di dimenticare di non consentire la "
"visualizzazione di post non pubblici."

#: ../../chapter-07.rst:4367
msgid ""
"In case you actually do want items left out by the common filter (for example, "
"allowing the admin to see non-public posts), you can either remove the filter:"
msgstr ""
"Nel caso in cui si desideri effettivamente che gli elementi vengano esclusi dal "
"filtro comune (ad esempio, consentendo all'amministratore di vedere i post non "
"pubblici), è possibile rimuovere il filtro:"

#: ../../chapter-07.rst:4375
msgid "or ignore it:"
msgstr "o ignorarlo:"

#: ../../chapter-07.rst:4383
msgid "Note that common_filters are ignored by the appadmin interface."
msgstr "Si noti che common_filters vengono ignorati dall'interfaccia appadmin."

#: ../../chapter-07.rst:4388
msgid "Custom ``Field`` types"
msgstr "Tipi di ''Campo'' personalizzati"

#: ../../chapter-07.rst:4390
msgid ""
"Aside for using ``filter_in`` and ``filter_out``, it is possible to define new/"
"custom field types. For example, suppose that you want to define a custom type "
"to store an IP address:"
msgstr ""
"Oltre all'uso di ''filter_in'' e ''filter_out'', è possibile definire tipi di "
"campo nuovi/personalizzati. Si supponga, ad esempio, di voler definire un tipo "
"personalizzato per archiviare un indirizzo IP:"

#: ../../chapter-07.rst:4435
msgid ""
"``SQLCustomType`` is a field type factory. Its ``type`` argument must be one of "
"the standard py4web types. It tells py4web how to treat the field values at the "
"py4web level. ``native`` is the type of the field as far as the database is "
"concerned. Allowed names depend on the database engine. ``encoder`` is an "
"optional transformation function applied when the data is stored and "
"``decoder`` is the optional reverse transformation function."
msgstr ""
"''SQLCustomType'' è una factory di tipi di campo. Il suo argomento ''type'' "
"deve essere uno dei tipi standard py4web. Indica a py4web come trattare i "
"valori dei campi a livello di py4web. ''nativo'' è il tipo di campo per quanto "
"riguarda il database. I nomi consentiti dipendono dal motore di database. "
"''encoder'' è una funzione di trasformazione opzionale applicata quando i dati "
"sono memorizzati e ''decoder'' è la funzione opzionale di trasformazione "
"inversa."

#: ../../chapter-07.rst:4443
msgid ""
"This feature is marked as experimental because can make your code not portable "
"across database engines."
msgstr ""
"Questa funzionalità è contrassegnata come sperimentale perché può rendere il "
"codice non portabile tra i motori di database."

#: ../../chapter-07.rst:4446
msgid "It does not work on Google App Engine NoSQL."
msgstr "Non funziona su Google App Engine NoSQL."

#: ../../chapter-07.rst:4449
msgid "Using DAL without define tables"
msgstr "Utilizzo di DAL senza tabelle definite"

#: ../../chapter-07.rst:4451
msgid "The DAL can be used from any Python program simply by doing this:"
msgstr ""
"Il DAL può essere utilizzato da qualsiasi programma Python semplicemente "
"facendo questo:"

#: ../../chapter-07.rst:4458
msgid ""
"i.e. import the DAL, connect and specify the folder which contains the .table "
"files (the app/databases folder)."
msgstr ""
"ad esempio, importare il DAL, connettersi e specificare la cartella che "
"contiene i file .table (la cartella app/databases)."

#: ../../chapter-07.rst:4461
msgid ""
"To access the data and its attributes we still have to define all the tables we "
"are going to access with ``db.define_table``."
msgstr ""
"Per accedere ai dati e ai loro attributi dobbiamo ancora definire tutte le "
"tabelle a cui accederemo con ''db.define_table''."

#: ../../chapter-07.rst:4464
msgid ""
"If we just need access to the data but not to the py4web table attributes, we "
"get away without re-defining the tables but simply asking py4web to read the "
"necessary info from the metadata in the .table files:"
msgstr ""
"Se abbiamo solo bisogno di accedere ai dati ma non agli attributi della tabella "
"py4web, ce la caviamo senza ridefinire le tabelle ma semplicemente chiedendo a "
"py4web di leggere le informazioni necessarie dai metadati nei file .table:"

#: ../../chapter-07.rst:4473
msgid "This allows us to access any db.table without need to re-define it."
msgstr ""
"Questo ci permette di accedere a qualsiasi db.table senza bisogno di "
"ridefinirlo."

#: ../../chapter-07.rst:4476
msgid "Distributed transaction"
msgstr "Transazione distribuita"

#: ../../chapter-07.rst:4478
msgid ""
"At the time of writing this feature is only supported by PostgreSQL, MySQL and "
"Firebird, since they expose API for two-phase commits."
msgstr ""
"Al momento in cui scriviamo questa funzionalità è supportata solo da "
"PostgreSQL, MySQL e Firebird, poiché espongono API per commit in due fasi."

#: ../../chapter-07.rst:4481
msgid ""
"Assuming you have two (or more) connections to distinct PostgreSQL databases, "
"for example:"
msgstr ""
"Supponendo di avere due (o più) connessioni a database PostgreSQL distinti, ad "
"esempio:"

#: ../../chapter-07.rst:4489
msgid "In your models or controllers, you can commit them concurrently with:"
msgstr ""
"Nei modelli o nei controller, è possibile eseguirne il commit "
"contemporaneamente a:"

#: ../../chapter-07.rst:4495
msgid "On failure, this function rolls back and raises an ``Exception``."
msgstr ""
"In caso di errore, questa funzione esegue il rollback e genera un''eccezione."

#: ../../chapter-07.rst:4497
msgid ""
"In controllers, when one action returns, if you have two distinct connections "
"and you do not call the above function, py4web commits them separately. This "
"means there is a possibility that one of the commits succeeds and one fails. "
"The distributed transaction prevents this from happening."
msgstr ""
"Nei controller, quando un'azione viene restituita, se si hanno due connessioni "
"distinte e non si chiama la funzione precedente, py4web le esegue il commit "
"separatamente. Ciò significa che esiste la possibilità che uno dei commit abbia "
"esito positivo e l'altro abbia esito negativo. La transazione distribuita "
"impedisce che ciò accada."

#: ../../chapter-07.rst:4505
msgid "Copy data from one db into another"
msgstr "Copiare i dati da un db all'altro"

#: ../../chapter-07.rst:4507
msgid ""
"Consider the situation in which you have been using the following database:"
msgstr ""
"Si consideri la situazione in cui è stato utilizzato il seguente database:"

#: ../../chapter-07.rst:4514
msgid ""
"and you wish to move to another database using a different connection string:"
msgstr ""
"e si desidera passare a un altro database usando una stringa di connessione "
"diversa:"

#: ../../chapter-07.rst:4521
msgid ""
"Before you switch, you want to move the data and rebuild all the metadata for "
"the new database. We assume the new database to exist but we also assume it is "
"empty."
msgstr ""
"Prima di eseguire il passaggio, è necessario spostare i dati e ricostruire "
"tutti i metadati per il nuovo database. Si presuppone che il nuovo database "
"esista, ma si presume anche che sia vuoto."

#: ../../chapter-07.rst:4527
msgid "Gotchas"
msgstr "Trucchi"

#: ../../chapter-07.rst:4530
msgid "Note on new DAL and adapters"
msgstr "Nota sui nuovi DAL e adattatori"

#: ../../chapter-07.rst:4534
msgid ""
"The source code of the Database Abstraction Layer was completely rewritten in "
"2010. While it stays backward compatible, the rewrite made it more modular and "
"easier to extend. Here we explain the main logic."
msgstr ""
"Il codice sorgente del Database Abstraction Layer è stato completamente "
"riscritto nel 2010. Pur rimanendo retrocompatibile, la riscrittura lo ha reso "
"più modulare e più facile da estendere. Qui spieghiamo la logica principale."

#: ../../chapter-07.rst:4538
msgid "The module “dal.py” defines, among other, the following classes."
msgstr "Il modulo \"dal.py\" definisce, tra l'altro, le seguenti classi."

#: ../../chapter-07.rst:4554
msgid ""
"Their use has been explained in the previous sections, except for "
"``BaseAdapter``. When the methods of a ``Table`` or ``Set`` object need to "
"communicate with the database they delegate to methods of the adapter the task "
"to generate the SQL and or the function call."
msgstr ""
"Il loro utilizzo è stato spiegato nelle sezioni precedenti, ad eccezione di "
"''BaseAdapter''. Quando i metodi di un oggetto ''Table'' o ''Set'' hanno "
"bisogno di comunicare con il database, delegano ai metodi dell'adapter il "
"compito di generare l'SQL e/o la chiamata di funzione."

#: ../../chapter-07.rst:4565
msgid "calls"
msgstr "Chiamate"

#: ../../chapter-07.rst:4571
msgid "which delegates the adapter by returning:"
msgstr "che delega l'adapter restituendo:"

#: ../../chapter-07.rst:4577
msgid ""
"Here ``db.mytable._listify`` converts the dict of arguments into a list of "
"``(field,value)`` and calls the ``insert`` method of the ``adapter``. ``db."
"_adapter`` does more or less the following:"
msgstr ""
"Qui ''db.mytable._listify'' converte il dict di argomenti in una lista di "
"''(field,value)'' e chiama il metodo ''insert'' dell'''adattatore''. ''db."
"_adapter'' fa più o meno quanto segue:"

#: ../../chapter-07.rst:4586
msgid "where the first line builds the query and the second executes it."
msgstr "dove la prima riga compila la query e la seconda la esegue."

#: ../../chapter-07.rst:4588
msgid "``BaseAdapter`` defines the interface for all adapters."
msgstr "''BaseAdapter'' definisce l'interfaccia per tutti gli adattatori."

#: ../../chapter-07.rst:4590
msgid "pyDAL at the moment of writing this book, contains the following adapters:"
msgstr ""
"pyDAL, al momento della stesura di questo libro, contiene i seguenti adattatori:"

#: ../../chapter-07.rst:4623
msgid "which override the behavior of the ``BaseAdapter``."
msgstr "che sovrascrivono il comportamento di ''BaseAdapter''."

#: ../../chapter-07.rst:4625
msgid "Each adapter has more or less this structure:"
msgstr "Ogni adattatore ha più o meno questa struttura:"

#: ../../chapter-07.rst:4662
msgid ""
"Looking at the various adapters as example should be easy to write new ones."
msgstr ""
"Guardando i vari adattatori come esempio dovrebbe essere facile scriverne di "
"nuovi."

#: ../../chapter-07.rst:4665
msgid "When ``db`` instance is created:"
msgstr "Quando viene creata l'istanza ''db'':"

#: ../../chapter-07.rst:4671
msgid ""
"the prefix in the uri string defines the adapter. The mapping is defined in the "
"following dictionary also in “dal.py”:"
msgstr ""
"Il prefisso nella stringa URI definisce l'adapter. La mappatura è definita nel "
"seguente dizionario anche in \"dal.py\":"

#: ../../chapter-07.rst:4678
msgid "couchdb"
msgstr "CouchDB"

#: ../../chapter-07.rst:4679
msgid "pydal.adapters.couchdb.CouchDB"
msgstr "pydal.adapters.couchdb.CouchDB"

#: ../../chapter-07.rst:4680
msgid "cubrid"
msgstr "Cubrid"

#: ../../chapter-07.rst:4681
msgid "pydal.adapters.mysql.Cubrid"
msgstr "pydal.adapters.mysql.Cubrid"

#: ../../chapter-07.rst:4682
msgid "db2:ibm_db_dbi"
msgstr "DB2:ibm_db_dbi"

#: ../../chapter-07.rst:4683
msgid "pydal.adapters.db2.DB2IBM"
msgstr "pydal.adapters.db2.DB2IBM"

#: ../../chapter-07.rst:4684
msgid "db2:pyodbc"
msgstr "DB2:PyodBC"

#: ../../chapter-07.rst:4685
msgid "pydal.adapters.db2.DB2Pyodbc"
msgstr "pydal.adapters.db2.DB2Pyodbc"

#: ../../chapter-07.rst:4686
msgid "firebird"
msgstr "Firebird"

#: ../../chapter-07.rst:4687
msgid "pydal.adapters.firebird.FireBird"
msgstr "pydal.adapters.firebird.FireBird"

#: ../../chapter-07.rst:4688
msgid "firebird_embedded"
msgstr "firebird_embedded"

#: ../../chapter-07.rst:4689
msgid "pydal.adapters.firebird.FireBirdEmbedded"
msgstr "pydal.adapters.firebird.FireBirdEmbedded"

#: ../../chapter-07.rst:4690
msgid "google:MySQLdb"
msgstr "google:MySQLdb"

#: ../../chapter-07.rst:4691
msgid "pydal.adapters.google.GoogleMySQL"
msgstr "pydal.adapters.google.GoogleMySQL"

#: ../../chapter-07.rst:4692
msgid "google:datastore"
msgstr "google:datastore"

#: ../../chapter-07.rst:4693 ../../chapter-07.rst:4695
msgid "pydal.adapters.google.GoogleDatastore"
msgstr "pydal.adapters.google.GoogleDatastore"

#: ../../chapter-07.rst:4694
msgid "google:datastore+ndb"
msgstr "google:datastore+ndb"

#: ../../chapter-07.rst:4696
msgid "google:psycopg2"
msgstr "Google:Psycopg2"

#: ../../chapter-07.rst:4697
msgid "pydal.adapters.google.GooglePostgres"
msgstr "pydal.adapters.google.GooglePostgres"

#: ../../chapter-07.rst:4698
msgid "google:sql"
msgstr "google:sql"

#: ../../chapter-07.rst:4699
msgid "pydal.adapters.google.GoogleSQL"
msgstr "pydal.adapters.google.GoogleSQL"

#: ../../chapter-07.rst:4700
msgid "informix"
msgstr "informix"

#: ../../chapter-07.rst:4701
msgid "pydal.adapters.informix.Informix"
msgstr "pydal.adapters.informix.Informix"

#: ../../chapter-07.rst:4702
msgid "informix-se"
msgstr "informix-se"

#: ../../chapter-07.rst:4703
msgid "pydal.adapters.informix.InformixSE"
msgstr "pydal.adapters.informix.InformixSE"

#: ../../chapter-07.rst:4704
msgid "ingres"
msgstr "Ingres"

#: ../../chapter-07.rst:4705
msgid "pydal.adapters.ingres.Ingres"
msgstr "pydal.adapters.ingres.Ingres"

#: ../../chapter-07.rst:4706
msgid "ingresu"
msgstr "ingresu"

#: ../../chapter-07.rst:4707
msgid "pydal.adapters.ingres.IngresUnicode"
msgstr "pydal.adapters.ingres.IngresUnicode"

#: ../../chapter-07.rst:4708
msgid "jdbc:postgres"
msgstr "jdbc:postgres"

#: ../../chapter-07.rst:4709
msgid "pydal.adapters.postgres.JDBCPostgre"
msgstr "pydal.adapters.postgres.JDBCPostgre"

#: ../../chapter-07.rst:4710
msgid "jdbc:sqlite"
msgstr "jdbc:sqlite"

#: ../../chapter-07.rst:4711 ../../chapter-07.rst:4713
msgid "pydal.adapters.sqlite.JDBCSQLite"
msgstr "pydal.adapters.sqlite.JDBCSQLite"

#: ../../chapter-07.rst:4712
msgid "jdbc:sqlite:memory"
msgstr "jdbc:sqlite:memoria"

#: ../../chapter-07.rst:4714
msgid "mongodb"
msgstr "mongoDB"

#: ../../chapter-07.rst:4715
msgid "pydal.adapters.mongo.Mongo"
msgstr "pydal.adapters.mongo.Mongo"

#: ../../chapter-07.rst:4716
msgid "mssql"
msgstr "MSSQL"

#: ../../chapter-07.rst:4717
msgid "pydal.adapters.mssql.MSSQL1"
msgstr "pydal.adapters.mssql.MSSQL1"

#: ../../chapter-07.rst:4718
msgid "mssql2"
msgstr "MSSQL2"

#: ../../chapter-07.rst:4719 ../../chapter-07.rst:4729
msgid "pydal.adapters.mssql.MSSQL1N"
msgstr "pydal.adapters.mssql.MSSQL1N"

#: ../../chapter-07.rst:4720
msgid "mssql3"
msgstr "MSSQL3"

#: ../../chapter-07.rst:4721
msgid "pydal.adapters.mssql.MSSQL3"
msgstr "pydal.adapters.mssql.MSSQL3"

#: ../../chapter-07.rst:4722
msgid "mssql3n"
msgstr "mssql3n"

#: ../../chapter-07.rst:4723
msgid "pydal.adapters.mssql.MSSQL3N"
msgstr "pydal.adapters.mssql.MSSQL3N"

#: ../../chapter-07.rst:4724
msgid "mssql4"
msgstr "MSSQL4"

#: ../../chapter-07.rst:4725
msgid "pydal.adapters.mssql.MSSQL4"
msgstr "pydal.adapters.mssql.MSSQL4"

#: ../../chapter-07.rst:4726
msgid "mssql4n"
msgstr "mssql4n"

#: ../../chapter-07.rst:4727
msgid "pydal.adapters.mssql.MSSQL4N"
msgstr "pydal.adapters.mssql.MSSQL4N"

#: ../../chapter-07.rst:4728
msgid "mssqln"
msgstr "mssqln"

#: ../../chapter-07.rst:4730
msgid "mysql"
msgstr "mysql"

#: ../../chapter-07.rst:4731
msgid "pydal.adapters.mysql.MySQL"
msgstr "pydal.adapters.mysql.MySQL"

#: ../../chapter-07.rst:4732
msgid "oracle"
msgstr "oracolo"

#: ../../chapter-07.rst:4733
msgid "pydal.adapters.oracle.Oracle"
msgstr "pydal.adapters.oracle.Oracle"

#: ../../chapter-07.rst:4734
msgid "postgres"
msgstr "postgres"

#: ../../chapter-07.rst:4735
msgid "pydal.adapters.postgres.Postgre"
msgstr "pydal.adapters.postgres.Postgre"

#: ../../chapter-07.rst:4736
msgid "postgres2"
msgstr "postgres2"

#: ../../chapter-07.rst:4737
msgid "pydal.adapters.postgres.PostgreNew"
msgstr "pydal.adapters.postgres.PostgreNew"

#: ../../chapter-07.rst:4738
msgid "postgres2:psycopg2"
msgstr "Postgres2:Psycopg2"

#: ../../chapter-07.rst:4739
msgid "pydal.adapters.postgres.PostgrePsycoNew"
msgstr "pydal.adapters.postgres.PostgrePsycoNew"

#: ../../chapter-07.rst:4740
msgid "postgres3"
msgstr "postgres3"

#: ../../chapter-07.rst:4741
msgid "pydal.adapters.postgres.PostgreBoolean"
msgstr "pydal.adapters.postgres.PostgreBoolean"

#: ../../chapter-07.rst:4742
msgid "postgres3:psycopg2"
msgstr "postgres3:psycopg2"

#: ../../chapter-07.rst:4743
msgid "pydal.adapters.postgres.PostgrePsycoBoolean"
msgstr "pydal.adapters.postgres.PostgrePsycoBoolean"

#: ../../chapter-07.rst:4744
msgid "postgres:psycopg2"
msgstr "postgres:psycopg2"

#: ../../chapter-07.rst:4745
msgid "pydal.adapters.postgres.PostgrePsyco"
msgstr "pydal.adapters.postgres.PostgrePsyco"

#: ../../chapter-07.rst:4746
msgid "pytds"
msgstr "pytds"

#: ../../chapter-07.rst:4747
msgid "pydal.adapters.mssql.PyTDS"
msgstr "pydal.adapters.mssql.PyTDS"

#: ../../chapter-07.rst:4749
msgid "pydal.adapters.sap.SAPDB"
msgstr "pydal.adapters.sap.SAPDB"

#: ../../chapter-07.rst:4750
msgid "spatialite"
msgstr "Spatialite"

#: ../../chapter-07.rst:4751 ../../chapter-07.rst:4753
msgid "pydal.adapters.sqlite.Spatialite"
msgstr "pydal.adapters.sqlite.Spatialite"

#: ../../chapter-07.rst:4752
msgid "spatialite:memory"
msgstr "spatialite:memoria"

#: ../../chapter-07.rst:4754
msgid "sqlite"
msgstr "sqlite"

#: ../../chapter-07.rst:4755 ../../chapter-07.rst:4757
msgid "pydal.adapters.sqlite.SQLite"
msgstr "pydal.adapters.sqlite.SQLite"

#: ../../chapter-07.rst:4756
msgid "sqlite:memory"
msgstr "sqlite:memoria"

#: ../../chapter-07.rst:4758
msgid "sybase"
msgstr "sybase"

#: ../../chapter-07.rst:4759
msgid "pydal.adapters.mssql.Sybase"
msgstr "pydal.adapters.mssql.Sybase"

#: ../../chapter-07.rst:4760
msgid "teradata"
msgstr "teradata"

#: ../../chapter-07.rst:4761
msgid "pydal.adapters.teradata.Teradata"
msgstr "pydal.adapters.teradata.Teradata"

#: ../../chapter-07.rst:4762
msgid "vertica"
msgstr "vertica"

#: ../../chapter-07.rst:4763
msgid "pydal.adapters.mssql.Vertica"
msgstr "pydal.adapters.mssql.Vertica"

#: ../../chapter-07.rst:4765
msgid ""
"the uri string is then parsed in more detail by the adapter itself. An updated "
"list of adapters can be obtained as dictionary with"
msgstr ""
"La stringa URI viene quindi analizzata in modo più dettagliato dall'adapter "
"stesso. Un elenco aggiornato degli adattatori può essere ottenuto come "
"dizionario con"

#: ../../chapter-07.rst:4773
msgid ""
"For any adapter you can replace the driver with a different one globally (not "
"thread safe):"
msgstr ""
"Per qualsiasi adattatore è possibile sostituire il driver con uno diverso a "
"livello globale (non thread-safe):"

#: ../../chapter-07.rst:4782
msgid ""
"i.e. ``mysqldb`` has to be *that module* with a .connect() method. You can "
"specify optional driver arguments and adapter arguments:"
msgstr ""
"cioè ''mysqldb'' deve essere *quel modulo* con un metodo .connect(). È "
"possibile specificare gli argomenti facoltativi del driver e gli argomenti "
"dell'adattatore:"

#: ../../chapter-07.rst:4789
msgid ""
"For recognized adapters you can also simply specify the name in the "
"``adapter_args``:"
msgstr ""
"Per gli adattatori riconosciuti è anche possibile specificare semplicemente il "
"nome nel ''adapter_args'':"

#: ../../chapter-07.rst:4802
msgid ""
"SQLite does not support dropping and altering columns. That means that py4web "
"migrations will work up to a point. If you delete a field from a table, the "
"column will remain in the database but will be invisible to py4web. If you "
"decide to reinstate the column, py4web will try re-create it and fail. In this "
"case you must set ``fake_migrate=True`` so that metadata is rebuilt without "
"attempting to add the column again. Also, for the same reason, SQLite is not "
"aware of any change of column type. If you insert a number in a string field, "
"it will be stored as string. If you later change the model and replace the type "
"“string” with type “integer”, SQLite will continue to keep the number as a "
"string and this may cause problem when you try to extract the data."
msgstr ""
"SQLite non supporta l'eliminazione e la modifica delle colonne. Ciò significa "
"che le migrazioni py4web funzioneranno fino a un certo punto. Se elimini un "
"campo da una tabella, la colonna rimarrà nel database ma sarà invisibile a "
"py4web. Se decidi di ripristinare la colonna, py4web proverà a ricrearla e "
"fallirà. In questo caso è necessario impostare ''fake_migrate=True'' in modo "
"che i metadati vengano ricostruiti senza tentare di aggiungere nuovamente la "
"colonna. Inoltre, per lo stesso motivo, SQLite non è a conoscenza di alcuna "
"modifica del tipo di colonna. Se si inserisce un numero in un campo stringa, "
"questo verrà memorizzato come stringa. Se in seguito si modifica il modello e "
"si sostituisce il tipo \"string\" con il tipo \"integer\", SQLite continuerà a "
"mantenere il numero come stringa e questo potrebbe causare problemi quando si "
"tenta di estrarre i dati."

#: ../../chapter-07.rst:4814
msgid ""
"SQLite doesn’t have a boolean type. py4web internally maps booleans to a 1 "
"character string, with ‘T’ and ‘F’ representing True and False. The DAL handles "
"this completely; the abstraction of a true boolean value works well. But if you "
"are updating the SQLite table with SQL directly, be aware of the py4web "
"implementation, and avoid using 0 and 1 values."
msgstr ""
"SQLite non ha un tipo booleano. py4web mappa internamente i valori booleani a "
"una stringa di 1 carattere, con 'T' e 'F' che rappresentano True e False. Il "
"DAL gestisce completamente questo aspetto; L'astrazione di un vero valore "
"booleano funziona bene. Ma se stai aggiornando la tabella SQLite direttamente "
"con SQL, tieni presente l'implementazione py4web ed evita di usare i valori 0 e "
"1."

#: ../../chapter-07.rst:4823
msgid ""
"MySQL does not support multiple ALTER TABLE within a single transaction. This "
"means that any migration process is broken into multiple commits. If something "
"happens that causes a failure it is possible to break a migration (the py4web "
"metadata are no longer in sync with the actual table structure in the "
"database). This is unfortunate but it can be prevented (migrate one table at "
"the time) or it can be fixed in the aftermath (revert the py4web model to what "
"corresponds to the table structure in database, set ``fake_migrate=True`` and "
"after the metadata has been rebuilt, set ``fake_migrate=False`` and migrate the "
"table again)."
msgstr ""
"MySQL non supporta più ALTER TABLE all'interno di una singola transazione. Ciò "
"significa che qualsiasi processo di migrazione viene suddiviso in più commit. "
"Se si verifica un errore che causa un errore, è possibile interrompere una "
"migrazione (i metadati py4web non sono più sincronizzati con la struttura "
"effettiva della tabella nel database). Questo è un peccato, ma può essere "
"evitato (migrare una tabella alla volta) o può essere risolto in seguito "
"(ripristinare il modello py4web a ciò che corrisponde alla struttura della "
"tabella nel database, impostare ''fake_migrate=True'' e dopo che i metadati "
"sono stati ricostruiti, impostare ''fake_migrate=False'' e migrare di nuovo la "
"tabella)."

#: ../../chapter-07.rst:4835
msgid "Google SQL"
msgstr "Google SQL"

#: ../../chapter-07.rst:4837
msgid ""
"Google SQL has the same problems as MySQL and more. In particular table "
"metadata itself must be stored in the database in a table that is not migrated "
"by py4web. This is because Google App Engine has a read-only file system. "
"PY4WEB migrations in Google SQL combined with the MySQL issue described above "
"can result in metadata corruption. Again, this can be prevented (by migrating "
"the table at once and then setting migrate=False so that the metadata table is "
"not accessed any more) or it can fixed in the aftermath (by accessing the "
"database using the Google dashboard and deleting any corrupted entry from the "
"table called ``py4web_filesystem``."
msgstr ""
"Google SQL ha gli stessi problemi di MySQL e altro ancora. In particolare, i "
"metadati della tabella stessa devono essere memorizzati nel database in una "
"tabella che non viene migrata da py4web. Questo perché Google App Engine ha un "
"file system di sola lettura. Le migrazioni PY4WEB in Google SQL combinate con "
"il problema MySQL descritto sopra possono causare il danneggiamento dei "
"metadati. Anche in questo caso, questo può essere evitato (migrando la tabella "
"in una sola volta e quindi impostando migrate=False in modo che la tabella dei "
"metadati non sia più accessibile) o può essere risolto in seguito (accedendo al "
"database utilizzando la dashboard di Google ed eliminando qualsiasi voce "
"danneggiata dalla tabella chiamata ''py4web_filesystem''."

#: ../../chapter-07.rst:4849
msgid "MSSQL (Microsoft SQL Server)"
msgstr "MSSQL (Microsoft SQL Server)"

#: ../../chapter-07.rst:4851
msgid ""
"MSSQL < 2012 does not support the SQL OFFSET keyword. Therefore the database "
"cannot do pagination. When doing a ``limitby=(a, b)`` py4web will fetch the "
"first ``a + b`` rows and discard the first ``a``. This may result in a "
"considerable overhead when compared with other database engines. If you’re "
"using MSSQL >= 2005, the recommended prefix to use is ``mssql3://`` which "
"provides a method to avoid the issue of fetching the entire non-paginated "
"resultset. If you’re on MSSQL >= 2012, use ``mssql4://`` that uses the "
"``OFFSET ... ROWS ... FETCH NEXT ... ROWS ONLY`` construct to support natively "
"pagination without performance hits like other backends. The ``mssql://`` uri "
"also enforces (for historical reasons) the use of ``text`` columns, that are "
"superseeded in more recent versions (from 2005 onwards) by ``varchar(max)``. "
"``mssql3://`` and ``mssql4://`` should be used if you don’t want to face some "
"limitations of the - officially deprecated - ``text`` columns."
msgstr ""
"MSSQL < 2012 non supporta la parola chiave SQL OFFSET. Pertanto il database non "
"può eseguire l'impaginazione. Quando si esegue un ''limitby=(a, b)'' py4web "
"recupererà le prime righe ''a + b'' e scarterà la prima ''a''. Ciò può "
"comportare un sovraccarico considerevole rispetto ad altri motori di database. "
"Se si utilizza MSSQL >= 2005, il prefisso consigliato da usare è ''mssql3://'' "
"che fornisce un metodo per evitare il problema di recuperare l'intero set di "
"risultati non impaginato. Se sei su MSSQL >= 2012, usa ''mssql4://'' che usa "
"''OFFSET ... RIGHE... RECUPERA PROSSIMO ... ROWS ONLY'' per supportare "
"l'impaginazione in modo nativo senza picchi di prestazioni come altri backend. "
"L'uri ''mssql://'' impone anche (per ragioni storiche) l'uso di colonne "
"''text'', che sono sovrapposte nelle versioni più recenti (dal 2005 in poi) da "
"''varchar(max)''. ''mssql3://'' e ''mssql4://'' dovrebbero essere usati se non "
"si vuole affrontare alcune limitazioni delle colonne ''text'' ufficialmente "
"deprecate."

#: ../../chapter-07.rst:4867
msgid ""
"MSSQL has problems with circular references in tables that have ONDELETE "
"CASCADE. This is an MSSQL bug and you work around it by setting the ondelete "
"attribute for all reference fields to “NO ACTION”. You can also do it once and "
"for all before you define tables:"
msgstr ""
"MSSQL presenta problemi con i riferimenti circolari nelle tabelle con ONDELETE "
"CASCADE. Si tratta di un bug di MSSQL e si aggira impostando l'attributo "
"ondelete per tutti i campi di riferimento su \"NO ACTION\". È anche possibile "
"farlo una volta per tutte prima di definire le tabelle:"

#: ../../chapter-07.rst:4879
msgid ""
"MSSQL also has problems with arguments passed to the DISTINCT keyword and "
"therefore while this works,"
msgstr ""
"MSSQL ha anche problemi con gli argomenti passati alla parola chiave DISTINCT e "
"quindi mentre questo funziona,"

#: ../../chapter-07.rst:4886
msgid "this does not"
msgstr "Ciò non"

#: ../../chapter-07.rst:4895
msgid ""
"Oracle also does not support pagination. It does not support neither the OFFSET "
"nor the LIMIT keywords. PY4WEB achieves pagination by translating a ``db(...)."
"select(limitby=(a, b))`` into a complex three-way nested select (as suggested "
"by official Oracle documentation). This works for simple select but may break "
"for complex selects involving aliased fields and or joins."
msgstr ""
"Inoltre, Oracle non supporta l'impaginazione. Non supporta né le parole chiave "
"OFFSET né quelle LIMIT. PY4WEB ottiene l'impaginazione traducendo un ''db(...). "
"select(limitby=(a, b))'' in una complessa selezione nidificata a tre vie (come "
"suggerito dalla documentazione ufficiale di Oracle). Questo funziona per la "
"selezione semplice, ma può interrompersi per le selezioni complesse che "
"coinvolgono campi e/o join con alias."

#: ../../chapter-07.rst:4903
msgid "Google NoSQL (Datastore)"
msgstr "Google NoSQL (archivio dati)"

#: ../../chapter-07.rst:4905
msgid ""
"Google NoSQL (Datastore) does not allow joins, left joins, aggregates, "
"expression, OR involving more than one table, the ‘like’ operator searches in "
"“text” fields."
msgstr ""
"Google NoSQL (Datastore) non consente join, left join, aggregazioni, "
"espressioni, OR che coinvolgono più di una tabella, l'operatore 'like' cerca "
"nei campi \"text\"."

#: ../../chapter-07.rst:4909
msgid ""
"Transactions are limited and not provided automatically by py4web (you need to "
"use the Google API ``run_in_transaction`` which you can look up in the Google "
"App Engine documentation online)."
msgstr ""
"Le transazioni sono limitate e non fornite automaticamente da py4web (è "
"necessario utilizzare l'API di Google ''run_in_transaction'' che è possibile "
"consultare nella documentazione di Google App Engine online)."

#: ../../chapter-07.rst:4913
msgid ""
"Google also limits the number of records you can retrieve in each one query "
"(1000 at the time of writing). On the Google datastore record IDs are integer "
"but they are not sequential. While on SQL the “list:string” type is mapped into "
"a “text” type, on the Google Datastore it is mapped into a "
"``ListStringProperty``. Similarly “list:integer” and “list:reference” are "
"mapped into ``ListProperty``. This makes searches for content inside these "
"fields types more efficient on Google NoSQL than on SQL databases."
msgstr ""
"Google limita anche il numero di record che puoi recuperare in ogni query (1000 "
"al momento della scrittura). Nell'archivio dati di Google, gli ID dei record "
"sono interi, ma non sequenziali. Mentre su SQL il tipo \"list:string\" è "
"mappato in un tipo \"text\", su Google Datastore è mappato in un "
"''ListStringProperty''. Allo stesso modo, \"list:integer\" e \"list:reference\" "
"sono mappati in ''ListProperty''. Ciò rende le ricerche di contenuti "
"all'interno di questi tipi di campi più efficienti su Google NoSQL rispetto ai "
"database SQL."
